---
title: Adder
categories:
  - SNU
  - 2-1
  - 논리설계
date: 2025-03-03 11:54:18
tags:
---

# 2's complement

- Sign an magnitude: First bit represents sign $1101_{(2)}=-5$
- 1's complement: Negative number has inversed bit $1101_{(2)} = -2$
- 2's complement: Negative number is represented as $N^* = 2^n-N$ $1101_{(2)} = -3$

Simple way: 2's complement of N is 1's complement of N + 1!

2's complement's addition and subtraction just works.  
However, overflow should be checked after operation.  
Overflow can be checked in two ways.

- If two number has same sign and addition has different sign with that one, overflow happened.
- If two highest carries in addition are different, overflow happened.

# Full adder

## Half adder

$$\begin{align*}
Sum &= A'B + AB' = A \oplus B \\
C_{out} &= AB
\end{align*}$$

Half adder adds two 1-bit numbers, then returns sum and carry.

## Full adder

$$\begin{align*}
Sum &= A \oplus B \oplus C_{in} \\
C_{out} &= AB + C_{in}(A + B) = AB + C_{in}(A \oplus B)
\end{align*}$$

Full adder adds two 1-bit numbers and carry, then returns sum and carry.  
By using $(A \oplus B)$ instead of $(A + B)$, we can implement full adder with two half adder and OR gate!

$$\begin{align*}
(A, B) &\xrightarrow{HA} (A \oplus B, AB) \\
(A \oplus B, C_{in}) &\xrightarrow{HA} (A \oplus B \oplus C_{in}, C_{in}(A \oplus B)) \\
A \oplus B \oplus C_{in} &\xrightarrow{\quad\,} Sum \\
(AB, C_{in}(A \oplus B)) &\xrightarrow{OR} C_{out}
\end{align*}$$

Chain 1-bit full adder to get n-bit full adder!  
We can check overflow by XORing two highest $C_{out}$.

## Subtractor

We can subtract by adding 2's complement.  
Lowest $C_{in}$ is useless - use as a control bit!

Connect control bit to 2:1 MUX that selects B or B'.  
If control bit is 0 (add), select B.  
If control bit is 1 (subtract), select B'.  
In subtract mode, adder adds B' + 1, which is 2's complement of B!

# Propagation delay of adder

## Ripple-carry adders

Assume single gate (XOR, AND, OR) has 1 propagation delay.  
When $C_{in}$ comes at time N, $C_{out}$ will be valid at time N + 2.

But in n-bit adder, previous carry should be valid to compute carry!  
In the worst case, $C_n$ is valid at time 2n.

## Carry-lookahead (CLA) adder

## Carry-lookahead logic

Carry generate: $G_i = A_i B_i$, If $G_i$ is set, carry should be generated.  
Carry propagate: $P_i = A_i \oplus B_i$, If $P_i$ is set, carry should be propagated.

Sum and carry can re-expressed in terms of generate/propagate.

$$\begin{align*}
S_i &= A_i \oplus B_i \oplus C_i \\
&= P_i \oplus C_i \\
C_{i+1} &= A_i B_i + C_i(A_i \oplus B_i) \\
&= G_i + C_iP_i
\end{align*}$$

By substituting, carry can be expressed in terms of generate/propagate alone! e.g. $C_3 = G_2 + P_2G_1 + P_2P_1G_0 + P_2P_1P_0C_0$  
Now every carry is valid at time 3, but lookahead carry unit becomes more complicated as $n$ grows.

Solution: split adders!
e.g. 16-bit adder can be implemented with four 4-bit adders + lookahead carry unit.  
Each 4-bit adders produces additional generate/propagate outputs: $G = G_3 + P_3G_2 + P_3P_2G_1 + P_3P_2P_1G_0, P = P_3P_2P_1P_0$  
Lookahead carry unit takes 4 generate/propagte bit and outputs carries!

## Carry-select adder

Do we really need to determine carry before addition?  
Use two adder - one assuming carry-in is 0 and another assuming carry-in is 1.  
After computing real carry, we can select correct output with 2:1 MUX.

Need redundant hardware, but achieves even lower delay than CLA adder!
