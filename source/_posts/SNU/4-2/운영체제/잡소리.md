---
categories:
  - SNU
  - 4-2
  - 운영체제
---
7-pt 마지막 슬라이드

Paging page tables  
문제점) Outer page table이 가리키는 주소가 VA(virtual address)여야함 (있을수도 없을수도 있으니까)  
참고로 현재 intel/risc-v 등은 page table이 전부 PA(physical address)라고 가정중

+ nested page fault 처리해야함...

그럼 page table은 에바고 kernel의 driver buffer, code 등의 메모리를 뺄 수 있냐?  
아니 안 쓰는 드라이버는 쓸때까지 빼놓을 수 없음?  
사실 이건 됨!  
kernel도 프로그램따리 -> kernel이 쓰는 주소도 VA -> kernel도 page fault/paging 가능!  
but kernel이 원한다면 아무 PA에 접근 가능; 그래서 kernel의 VA는 PA랑 1대1 매핑함  
하지만 user page fault 처리 중 kernel page fault 같은걸 처리해야하는 nested page fault 문제는 그대로 있다...  
kernel 해봤자 1~2MB니까 그냥 웬만하면 page fault 안 나게 만들어둠...

8-tlb

page table entry 전체를 caching하는 놈 (권한 등도 중요한 정보라 VA->PA 주소변환만 저장하는게 아님)
요즘 TLB는 하드웨어?

9-mmap

file을 mapping하는게 가능  
사실 read 같은 system call은 page fault나면 파일과 소통하는 방식  
fgets는 왜 느리냐 -> C library가 user level -> 버퍼도 user level -> 메모리 복사를 몇번 하는겨

mmap -> 바로 커널 메모리를 (uesr VA로) access -> 메모리 복사 최소화

10-swap

Consider physical memory as a cache for disks

How to swap -> Overlays

여담 paging은 CPU 지원 필요
e.g. 지구 한바퀴를 page fault..??
optimal: 가장 안 쓰이는걸 빼는게 최적
