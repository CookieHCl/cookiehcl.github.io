---
title: 테스트 주도개발
categories:
  - BOOK
  - 'IT,프로그래밍'
date: 2023-07-30 09:17:56
tags:
---

## 싹 고치고 date 최신화하기

date: 2023-07-30 09:17:56

# 다중통화 예제

목표: 환율이 주어져 있을 때 통화가 다른 주식들의 총 가격을 달러로 보고 싶음

- 금액을 주식 수만큼 곱할 수 있어야 함
- 서로 다른 통화로 되어있는 금액을 합할 수 있어야 함

1. 일단 테스트 작성
2. 아무 컴파일 되는 코드 작성
3. 테스트 실행해서 실패하는지 확인
4. 테스트 성공하도록 작성
  **기능을 구현하는게 아님!!** 테스트가 5*2=10이면 그냥 `return 10;`도 가능
  최대한 빨리 통과하도록 구현하기만 하면 됨 (이를 **스텁 구현**, stub implementation이라고 함)
5. 중복 제거
  코드끼리의 중복 말고도 테스트와 코드간의 중복도 중복임
  ex) 위 예제는 테스트와 코드 모두 10이라는 값이 중복됨
  중복 = 의존성의 징후

1~4는 최대한 빨리!! 생각을 하면서 구현하면 안 됨
5는 제대로 만들어야 함!! 1~4에서 날림으로 구현한 부분을 수정하는 과정

## 테스트 성공하도록 작성

1. 그냥 상수 반환 후 `return 10;` 진짜 코드가 나올 때까지 단계적으로 상수를 변수로 바꿔감 (중복 제거과정)
2. 구현이 명백하면 실제 구현을 바로 구현 (위 예제는 그냥 `return amount * multiplier;`임이 명확함)
  but 실패시 그냥 포기하고 1번으로 회귀
3. 삼각측량법: 답이 안 보일 경우 사용
  테케를 2개씩 만들고 (5*2=10, 5*3=15) 둘 다 통과하는 코드를 작성
  단점: 테스트가 2배가 되므로 약간의 중복이 생기고 테스트 시간이 길어짐

- 추가 기능 구현으로 테스트 추가가 필요해지면 추가해야 함!
- 반대로 리팩토링으로 테스트가 필요없어지면 제거해야 함!

## 테스트의 질

- 명령문 커버리지 (statement coverage)
  TDD는 100%를 목표로 함 (즉, 테스트 케이스로 모든 코드를 검증해야 함)
- 결함 삽입 (defect injection)
  Jester 등의 툴로 코드의 의미를 바꿨을 때 테스트가 실패해야 함

# xUnit 예제

## 테스트 3A 패턴

1. 준비(Arrange) - 객체 생성
2. 행동(Act) - 자극 줌
3. 확인(Assert) - 결과 검사

문제점: 준비과정은 겹치는 경우가 많음
ex) 5+7, 5-7, 5*7을  검사할 때 5, 7은 같은 객체를 사용함
새로운 객체를 얼마나 자주 생성해야 하는가? -> 성능 vs 격리가 충돌함
성능 - 객체 생성 최소화 -> 테스트 속도가 빨라짐
격리 - 매번 새 객체 생성 -> 각 테스트의 결과가 다른 테스트에 영향을 미치지 않음

여담) 매개변수 수집(collecting parameter)
컴포지트 패턴(Composite) -> 1개든 n개든 interface가 같음

# 테스트 주도 개발의 패턴

- 테스트는 자동화될 수 있어야 함!
- 테스트는 서로 아무 영향이 없어야 함 (격리시켜야 함)
  - 암묵적으로 테스트가 실행 순서에 독립적이기 됨
  - 응집도가 높고 결합도가 낮은 설계가 만들어짐
- 모든 테스트의 목록을 적어놓기
  단, 지금 할 일인지 나중에 할 일인지는 구분 필요 (실패하는 테스트는 지금, 리팩토링은 나중에)
- 테스트 작성 직후 바로 코드를 작성하고, 코드 작성 중엔 테스트를 추가로 만들지 않음
- assert first; 테스트를 작성할 때 단언(assert)를 가장 먼저 작성해라
- 테스트 데이터는 읽기 쉽고 따라하기 좋아야 함
  - 1이랑 2가 개념적으로 같다면 읽기 쉬운 1을 사용함 (불필요하게 1이랑 2를 둘다 테스트하면 안 됨)
  - 외부 이벤트의 결과를 이용하는 실시간 시스템을 테스트할 때나, 예전 시스템과 현재 시스템의 출력을 비교할 때나, 시뮬레이션 시스템을 리팩토링 한 후 결과를 비교하는 등의 경우엔 실제 데이터를 사용할 수도 있음
  - 상수 대신 수식을 쓸 수도 있음
    ex) 환전 수수료가 1.5%인 경우 테스트 데이터로 `49.25` 대신 `50*(1-0.015)`를 사용
    `STANDARD_COMMISION`처럼 기호 상수(symbolic constant)를 쓸 수도 있음
- 첫 번째 테스트는 operation이 아무 일도 안 하는 경우를 테스트
  ex) 입력이 다각형인 operation리면 첫 테스트로 빈 다각형이나 제일 간단한 다각형을 테스트
- 학습 테스트: 외부 라이브러리/API가 제대로 작동하는지 확인하기 위해 테스트를 사용
  가끔 API에 버그가 있는 경우 버그가 있어야만 통과하는 테스트를 만들면 패치노트를 일일히 읽지 않더라도 버그가 수정되었다는 것을 알 수 있음
- 회귀 테스트(regression test): 시스템 장애 발견시 장애로 인해 실패하는 테스트 or 장애가 수정되었다고 볼 수 있는 테스트를 작성
  만약 장애를 손쉽게 격리시킬 수 없다면 설계에 문제가 있다는 뜻이므로 리팩토링 필요
- 혼자 프로그래밍하는 경우 마지막 테스트가 실패한 상태로 작업을 멈춤
  어디서부터 시작해야 하는지 알기 쉬움
- 팀 프로그래밍의 경우 모든 테스트가 통과한 상태로 작업을 멈춤
  받아온 코드가 완벽하다는 확신을 가질 수 있음

## 테스트 패턴

### 모의 객체(Mock Object)

DB 등 비용이 많이 들고나 복잡한 리소스에 의존하는 객체 테스트시 상수를 반환하도록 만든 속임수 버전의 리소스를 사용함

- 성능, 견고함(실패할 일이 없음), 가독성(실제 데이터 대신 알기 쉬운 데이터 사용 가능)에서 이득을 봄
- 모의 객체용 테스트를 추가해 실제 객체와 같은 기능을 확인해야 함

### 셀프 션트(Self Shunt)

두 객체가 대화하는지 테스트해야 할 때 각 객체가 테스트 케이스와 대화하도록 (즉, 테스트 케이스를 listener로) 만들면 됨 (일종의 모의 객체)

프로그램의 각 단계를 따로따로 테스트하기 위해 모의 객체를 만들 수도 있음 (p.362)

### 로그 문자열

메시지 호출 순서를 테스트해야 할 때 문자열로 로그를 남겨서 문자열 비교를 하면 됨 (순서 상관 없을 시 set 등을 사용)

### 크래시 테스트 더미(Crash Test Dummy)

에러 상황을 테스트해야 할 때 항상 예외를 발생시키는 특수한 객체를 만들면 됨 (일종의 모의 객체)

ex: 메모리 초과나 파일시스템 에러 등 평상시에 거의 볼일 없는 에러들

Java의 경우 anonymous inner class로 쉽게 테스트할 수 있음

p.239

```Java
public void testFileSystemError() {
  File f = new File("foo") {
    public boolean createNewFile() throws IOException {
      throw new IOException();
    }
  };
  try {
    f.createNewFile();
  }
  catch ...
}
```

## xUnit 패턴

### 단언(assert)

단언은 구체적이여야 함

ex: `assertTrue(rectangle.area != 0)`은 100이여도 50이여도 통과하는 테스트
`assertTrue(rectangle.area == 50)`처럼 정확한 조건을 테스트해야 함

### 픽스처(fixture)

여러 테스트에 동일한 객체가 사용될 경우 `setUp()`에서 할당
자원 해제가 필요한 객체인 경우 `teardown()`에서 해제

- 인터페이스 변경시 코드 한 곳만 변경하면 됨 (중복 제거)
- 객체 할당하는 코드를 매번 적지 않아도 돼서 테스트 작성속도가 빨라짐

### 예외가 발생해야만 하는 테스트

ex) IllegalArgumentException이 발생해야 하는 경우

```
try {
  test...
  fail();
} catch (IllegalArgumentException expected) {
}
```

`fail()`은 테스트를 실패하게 하는 함수

## 디자인 패턴

### 테스트 작성 시

#### 커맨드

작업 호출을 함수로 만들어 바로 호출하지 않고 클래스로 만듦 -> 원하는 시점에 호출할 수 있고, 로그를 남기는 등의 다른 작업을 할 수 있음
ex) Java의 Runnable

```
interface Runnable {
  public abstract void run();
}
```

#### 값 객체

객체가 생성될 때 객체의 상태를 설정하고 절대 변할 수 없도록 함
값이 변하는 operation의 경우 새 객체를 리턴함

동등성(equality) 구현 필수!!

### 리팩토링 시

#### 널 객체

**p.274**
null을 리턴하는 대신 다른 정상적인 객체와 같은 프로토콜을 가지는 객체를 리턴함

#### 템플릿 메소드

작업 순서만 있고 작업이 중해지지 않았을 때 메소드들을 부르는 메소드를 만듦

각 메소드의 기본 구현을 구현할 수도 있고 안 할 수도 있음

ex)

```
public void runBare() throws Throwable {
  setUp();
  try {
    runTest();
  }
  finally {
    tearDown();
  }
}
```

`setUp(), runTest(), tearDown()`은 하위 클래스에서 구현함

#### 플러거블 객체

mode를 enum/bool 등을 사용하는 대신 한 interface를 공유하는 객체들로 만듦 -> if나 switch문을 사용할 필요가 없어짐

#### 플러거블 셀렉터

인스턴스별로 서로 다른 메소드를 동적으로 호출할 때 메소드 이름에 해당하는 메소드를 동적으로 호출함

단점: 뭐가 호출됐는지 코드를 추적하기 어려움

### 테스트 작성 & 리팩토링 시

#### 팩토리 메소드

생성자를 직접 호출하는 대신 메소드를 통해 객체를 생성함

단점: 메소드가 할법한 일이 아니라 직관성이 떨어짐

#### 컴포지트

하나의 객체가 여러 객체들의 행위를 조합한 것처럼 행동하도록 만듦 -> 단일 객체와 객체 집합이 같은 interface를 쓰도록 구현함

#### 수집 매개변수

여러 객체에 걸쳐있는 operation의 결과를 수집할 때 매개변수로 결과가 수집될 객체를 넘김

#### 싱글톤

쓰지 마라.

## 리팩토링 패턴

### 차이점 일치시키기

비슷한 반복문, 조건문, 클래스를 동일하게 만든 다음 하나를 제거함

### 변화 격리하기

객체나 메소드의 일부만 바꿀 때 우선 그 부분을 격리한 후에 수정함

### 데이터 이주시키기

표현 양식을 변경할 때 사용

ex) 1개만 처리하는 메소드가 collection을 처리하도록 만들 때
ex) vector/enumerator에서 collection/iterator로 바꿀 때

#### 내부 -> 외부(API)

1. 새로운 포맷의 인스턴스 변수 추가
2. 기존 포맷의 인스턴스 변수를 세팅하는 모든 부분에서 새로운 인스턴스 변수도 세팅하게 만듦
3. 기존 변수를 사용하는 모든 곳에서 새 변수를 사용하게 만듦
4. 기존 포맷을 제거
5. 새 포맷에 맞게 외부 인터페이스 변경

#### 외부 -> 내부

1. 새 포맷으로 인자를 추가
2. 새 포맷 인자에서 이전 포맷의 내부적 표현 방식으로 변역
3. 이전 포맷 인자 삭제
4. 이전 포맷을 사용하는 것들을 새 포맷을 사용하도록 바꿈
5. 이전 포맷을 지움

### 메소드 추출하기

길고 복잡한 메소드를 읽기 쉽게 만듦
일부 비슷한 내용이 있는 두 메소드에서 중복을 제거함

### 메소드 인라인

제어 흐름이 너무 꼬여있거나 산개한 경우 사용

### 인터페이스 추출하기

operation에 대한 두 번째 구현 추가가 필요할 때

### 메소드 옮기기

한 메소드에서 다른 객체에 두 개 이상의 메시지를 보낼 때 사용
(단, 원래 객체의 필드들이 갱신된다면 옮기면 안 됨)

### 메소드 객체

여러 개의 매개변수와 지역변수를 갖는 복잡한 메소드가 있는 경우 메소드를 객체로 만들어서 `object.run()`을 불러야 할 수도 있음

### 매개변수 추가

새 테스트가 제시하는 새로운 상황을 완수하기 위해 사용

### 메소드 매개변수를 생성자 매개변수로 옮김

동일한 매개변수가 같은 객체의 서로 다른 메소드로 전달되는 경우 사용
반대로 인스턴스 변수가 하나의 메소드에서만 쓰인다면 생성자 매개변수를 메소드 매개변수로 옮김

# TDD 마스터하기

## 좋은 테스트의 여부

긴 셋업코드: 하나의 단언을 위해 수백 줄의 객체 생성 코드가 필요하다면 객체가 너무 크다는 뜻
셋업 중복: 공통의 셋업 코드를 넣어줄 공통의 장소를 찾기 힘들다면 서로 밀접하게 엉킨 객체들이 너무 많다는 뜻
실행시간이 오래 걸리는 테스트: 애플리케이션의 일부만 테스트할 수 없는 설계 문제
깨지 쉬운 테스트: 테스트가 예상치 못 하게 실패한다면 애플리케이션의 특정 부분이 다른 부분에 이상하게 영향을 끼친다는 뜻 -> 연결을 끊거나 두 부분을 합쳐 영향력을 없애야 함

## 테스트를 얼마나 작성해야 하나?

실패간 평균시간(MTBF, Mean Time Between Failure) 고려
MAXINT나 메모리 초과 등의 상황을 고려해야 하나?
내가 그럴 일이 없다면 굳이 테스트를 만들 필요가 없음 but 내가 우주비행선을 만드는 등 모든 경우를 테스트해야 한다면 테스트를 만들어야 함

## 테스트를 언제 지워야 하나?

테스트 삭제로 인해 자신감이 줄어들 것 같으면 삭제하지 않음
두 테스트가 동일한 부분을 실행하더라도 서로 다른 시나리오면 삭제하지 않음
중복된 두 테스트라면 덜 유용한 테스트를 삭제

## 프로젝트 중반에 TDD를 도입하려면 어떻게 해야 하나?

기존 코드는 TDD를 염두에 두지 않아 일부분만 테스트할 수 있도록 설계되어 있지 아노음

1. 변경의 범위를 제한
  코드 전체를 위한 테스트를 다 만들고 리팩토링을 시작하면 리팩토링만 몇 달이 걸림
  코드 일부분만 테스트를 만들고 바로 리팩토링 시작
2. 테스트와 리팩토링 사이의 교착상태(deadlock)를 해결
  테스트를 하려면 리팩토링이 필요한데 리팩토링 시 에러가 없으려면 테스트가 필요함
  교착상태를 해결하기 위해서는 테스트 대신 다른 방법으로 피드백을 얻어야 함

- 아주 조심스럽게 작업하기
- pair programming, 파트너와 함께 작업하기

## 왜 TDD가 잘 작동하는가?

- 결함 감소: 테스트를 통해 버그가 없다고 확신할 수 있음 -> 자신감 상승
- 설계 결정 피드백 고리 단축: 테스트는 수 초에서 수 분밖에 안 걸리기 때문에 설계 결정 시간이 짧아짐
- bit.ly/3jWhI6P
