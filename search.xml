<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>굳이굳이 Hexo로 블로그 시작한 이유</title>
    <url>/posts/1/</url>
    <content><![CDATA[<h1>동기</h1>
<p>Github Pages랑 Markdown을 이용해서 블로그를 만들고 싶어서 시작했다.</p>
<p>처음에는 직접 html이랑 javascript를 배워서 만들어볼까 했지만, 맨땅에서 시작하기엔 웹프로그래밍에 대해 아는게 없었고, 블로그의 주 목적은 게시글을 작성하는 건데, html 단계부터 만들기 시작하면 내가 게시글을 만들 때마다 html을 새로 만들거나, 티스토리에 있는 것마냥 게시글 편집기를 직접 만들어야 할 것 같아서 포기했다.</p>
<p>결국 블로그의 주 목적은 <s>정확히는 블로그가 망하지 않으려면</s> 게시글을 작성하는 것이고, 이를 위해서는 게시글을 <strong>쉽고 빠르게</strong> 작성할 수 있어야 한다고 생각해서 Markdown 블로그를 만들었다.</p>
<p>물론 티스토리 블로그 같은 서비스를 이용해도 되지만, 혹시나 먼 미래에 갑자기 'html부터 새로 만들어보는 나만의 블로그' 같은 짓을 할 수도 있을 것 같아서 게시글들을 쉽게 이전할 수 있도록 Markdown으로 게시글을 작성했다.</p>
<h1>그래서 왜 Hexo?</h1>
<p>사실 가장 잘 알려진 방법은 <a href="https://jekyllrb-ko.github.io/">Jekyll</a>을 사용하는 것이다. 일단 Github Pages에서 <a href="https://docs.github.com/en/pages/setting-up-a-github-pages-site-with-jekyll/about-github-pages-and-jekyll">공식적으로 권장하기도</a> 하고, Markdown을 사용한 static site generator중에서는 가장 유명할 것이다.</p>
<p>하지만 굳이굳이 Hexo를 사용해서 블로그를 시작한 이유는 게시글 주소 때문인데, Jekyll은 주소로 게시글 제목, 날짜 등을 사용하지만 <em>(ex: blog.com/2023/11/30/blog_sijak)</em> Hexo는 티스토리처럼 주소로 숫자를 사용하는 <a href="https://github.com/rozbo/hexo-abbrlink2">플러그인</a>이 있었다. <em>(ex: blog.com/123)</em></p>
<p>막상 시작해보니 Hexo를 사용하게 된 계기인 주소 플러그인이 잘 작동하지 않는 문제점이 있긴 했지만, Hexo에서 지원하는 기능들이 상당히 많아서 Jekyll로 시작했으면 더 불편했을 것 같다.</p>
<h2 id="장점">장점</h2>
<ul>
<li>대부분 Hexo 유저가 사용하는 <a href="https://theme-next.js.org/">Next Theme</a>이 정말 이쁘다!</li>
<li>ruby를 사용하는 Jekyll과 달리, node.js를 사용해서 npm으로 쉽게 설치가 가능하다.
<ul>
<li>솔직히 ruby는 아무도 안 쓰잖아...</li>
</ul>
</li>
<li>중국인이 사용하기 때문에 다국어 지원이 잘 되어있어 겸사겸사 한국인도 이득을 봤다.</li>
<li>Jekyll은 진짜 글만 모아둔 느낌인데 Hexo는 카테고리, 댓글, 글 검색 기능 등 일반적인 블로그 서비스들이 제공하는 기능들도 지원하려고 노력한다.</li>
<li>syntax highlighting, LaTeX 지원이 기본으로 되어있다.</li>
<li>이외에도 유튜브 동영상, 그래프 등 Markdown으로 표현할 수 없는 부분을 지원하기 위한 플러그인들이 많다.</li>
<li>광고, 블로그 홍보에 미쳐있어서 블로그 홍보하는 documentation까지 있다.</li>
</ul>
<h2 id="단점">단점</h2>
<ul>
<li>수상할 정도로 중국인들만 사용해서 그냥 귀찮게 영어 쓰는 대신 중국어로 issue, plugin 등을 남기는 경우가 많다. 심하면 그냥 README를 중국어로 적는 경우도 있다.</li>
<li>Hexo도 광고에 미쳐있다. 무려 공식 documentation에 광고가 뜬다....</li>
<li>Hexo의 기능이 뛰어나기 보단 <a href="https://theme-next.js.org/">Next Theme</a>에서 지원하는 기능이 많아 테마가 제한되는 느낌이 있다.
<ul>
<li>Hexo plugin들도 Next Theme을 사용하는 가정 하에 만드는 경우도 있다.</li>
<li>위 장점들 중에서도 Next Theme에만 해당되는 장점들도 있다.</li>
<li>아마 다른 테마도 맞는 plugin들만 깔아주면 Next Theme과 같은 기능을 할 것 같긴 한데 다른 테마는 안 써봐서 모르겠다.</li>
</ul>
</li>
<li>유저 수 적은 서비스가 늘 그렇듯이 API 등 심화된 부분으로 가면 documentation이 잘 안 되어있다. 덕분에 plugin 만들 때 좀 고생했다.</li>
</ul>
<h1>결론</h1>
<p>그래서 Hexo를 써야 하냐고 묻는다면 쓰는게 좋은 것 같다. <s>본인처럼</s> 주는 것에 만족하지 못 하고 직접 건드리려고 하면 조금 애먹을 수 있지만 Next Theme이 워낙 잘 되어있어서 건드릴 일이 거의 없다.</p>
<p>Jekyll은 정말 기본적인 기능만 지원해서 카테고리, 검색 기능 같은 것을 지원하려면 어차피 plugin들을 찾아보거나, 직접 코딩하는 등 힘들게 살아야하는데 Hexo는 수많은 중국인들이 이미 귀찮은 작업들을 다 끝내줘서 찾아볼 필요가 없다. 감사합니다 따-거</p>
]]></content>
      <categories>
        <category>BLOG</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo로 블로그 시작하기</title>
    <url>/posts/2/</url>
    <content><![CDATA[<h1>설치</h1>
<p>먼저 <a href="https://nodejs.org/en/download/">node.js</a>와 <a href="https://git-scm.com/downloads">git</a>을 깔아준다.</p>
<p>그 후 hexo를 설치한 다음 블로그 폴더를 만들어준다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h1>실행</h1>
<p><code>hexo new --path &lt;path&gt; &lt;title&gt;</code>로 원하는 경로에 게시글을 만들 수 있다. 물론 Front matter만 알맞게 작성한다면 직접 Markdown 파일을 만들어도 상관없다.</p>
<p>게시글을 다 작성했다면 <code>hexo generate</code>로 블로그를 생성하고, <code>hexo server</code>로 블로그를 로컬 서버로 구동시킨다.<br>
<code>hexo generate -w</code>를 사용하면 파일이 편집될 때마다 블로그를 계속 생성해준다.</p>
<p>문제는 <code>hexo server</code>가 hot/live reloading을 지원하지 않아 블로그가 새로 생성돼도 브라우저를 새로고침 해야 반영이 된다.<br>
그래서 어쩔 수 없이 <a href="https://browsersync.io/">Browsersync</a>를 깔아야 했는데, <code>npx browser-sync ./public -w</code>를 사용하면 파일이 편집될 때마다 새로 생성된 블로그를 볼 수 있다.</p>
<p>일부 변경사항은 <code>hexo generate</code>를 아무리 해도 적용이 안 되는데, (_config.yml 변경 등) 이때는 <code>hexo clean</code>으로 캐시를 지워줘야 한다.</p>
<h1>배포</h1>
<p>GitHub Pages니까 GitHub Actions을 사용하기로 했다.<br>
먼저 repository 설정에서 GitHub Pages를 활성화시켜야 한다.</p>
<ul>
<li>Code and automation - Pages에서 Source를 <strong>Deploy from branch</strong>로 해준다.</li>
<li>Branch는 <code>gh-pages</code>로 선택한다.</li>
</ul>
<p>이후 아래 파일을 <code>.github/workflows/pages.yml</code>으로 저장한다.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Github</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">LTS</span> <span class="string">Node.js</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;lts/*&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">npm-cache-$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm-cache-$&#123;&#123; runner.os &#125;&#125;</span></span><br><span class="line"><span class="string">          npm-cache</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        npm install</span></span><br><span class="line"><span class="string">        npx hexo generate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/actions/checkout">actions/checkout</a>, <a href="https://github.com/actions/setup-node">actions/setup-node</a>는 말 그대로의 일을 하고, <a href="https://github.com/actions/cache">actions/cache</a>는 workflow가 빠르게 돌 수 있도록 <code>node_modules</code> 폴더를 캐싱해둔다.</p>
<p>그 후 <code>npx hexo generate</code>로 블로그를 생성한 다음 <a href="https://github.com/peaceiris/actions-gh-pages">peaceiris/actions-gh-pages</a>로 <code>./public</code> 폴더를 GitHub Pages branch에 올리면 된다.</p>
<h1>NexT Theme 설치</h1>
<p>NexT Theme 설치는 <code>npm install hexo-theme-next</code>로 간단하게 할 수 있다. 이후 <code>_config.yml</code>에서 <code>theme: next</code>로 설정해주면 된다.</p>
<p>그 후 NexT Theme 설정 파일을 따로 만들어줘야 하는데, <code>node_modules/hexo-theme-next/_config.yml</code>을 <code>_config.next.yml</code>로 복사해주고 <code>_config.next.yml</code>만 수정하면 된다.</p>
<h1>What's Next...?</h1>
<p>이 이후로는 자유롭게 <a href="https://hexo.io/docs/configuration.html">hexo documentation</a>과 <a href="https://theme-next.js.org/docs/theme-settings/">NexT documentation</a>을 참고하면서 원하는 대로 수정하면 된다.</p>
<p>다른 <a href="https://hexo.io/plugins/">plugin</a>들도 살펴보면서 필요한 것이 있다면 다운받아도 된다. 몇 가지 추천 플러그인들은 다음과 같다.</p>
<ul>
<li><a href="https://github.com/xu-song/hexo-auto-category">hexo-auto-category</a>: post의 경로대로 category를 만들어준다.</li>
<li><a href="https://github.com/chekun/hexo-excerpt">hexo-excerpt</a>: 블로그 메인화면에서 post가 너무 길 경우 일부만 보여준다.</li>
<li><a href="https://github.com/next-theme/hexo-generator-searchdb">hexo-generator-searchdb</a>: 검색기능을 만들어준다! 자세한 설명은 <a href="https://theme-next.js.org/docs/third-party-services/search-services.html?highlight=searchdb#Local-Search">NexT documentation</a>을 참고하자.</li>
</ul>
]]></content>
      <categories>
        <category>BLOG</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo permalink 숫자로 나오게 하기</title>
    <url>/posts/3/</url>
    <content><![CDATA[<h1>문제점</h1>
<p>분명 Hexo에는 이걸 지원하는 <a href="https://github.com/rozbo/hexo-abbrlink2">plugin</a>이 있고, 이것 때문에 Hexo로 블로그 만들기를 시작했는데, 정작 이 plugin이 작동하질 않았다...</p>
<p>아직 Hexo 작동원리를 정확히 아는 것은 아니라 모르겠지만, 대충 이유를 추측하자면 저 plugin은 <a href="https://hexo.io/api/filter_post-permalink">post_permalink</a> filter에서 주소를 계산하는데, 게시글 주소가 여러 곳에서 쓰이다 보니 (메인화면, 이전/다음 글, 카테고리 등...) post_permalink filter가 여러 번 불린다.</p>
<p>근데 plugin 제작자가 이럴거라고 생각을 못 했는지, 아니면 post_permalink가 불릴때마다 순서가 뒤죽박죽이라던지, 여러가지 이유로 게시글 주소를 계산할 때마다 permalink를 다르게 계산하고, 결국 링크가 제대로 작동하지 않는 문제가 생겼다.</p>
<h1>해결책</h1>
<p>결국 plugin을 직접 만들기로 했다... 아래 파일을 <code>scripts/abbrlink.js</code>로 저장한다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> abbrlinks = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_generate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> posts = hexo.<span class="property">locals</span>.<span class="title function_">get</span>(<span class="string">&#x27;posts&#x27;</span>).<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">let</span> undefined_posts = [];</span><br><span class="line">    <span class="keyword">let</span> max_abbrlink = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get max abbrlink</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> post <span class="keyword">of</span> posts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (post.<span class="property">abbrlink</span>) &#123;</span><br><span class="line">            abbrlinks[post.<span class="property">_id</span>] = post.<span class="property">abbrlink</span>;</span><br><span class="line">            max_abbrlink = <span class="title class_">Math</span>.<span class="title function_">max</span>(max_abbrlink, post.<span class="property">abbrlink</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            undefined_posts.<span class="title function_">push</span>(post);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate abbrlink for undefined posts</span></span><br><span class="line">    undefined_posts.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">date</span> - b.<span class="property">date</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> post <span class="keyword">of</span> undefined_posts) &#123;</span><br><span class="line">        abbrlinks[post.<span class="property">_id</span>] = ++max_abbrlink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;post_permalink&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// if abbrlink is already set, do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">abbrlink</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set abbrlink if abbrlink is generated</span></span><br><span class="line">    <span class="keyword">const</span> abbrlink = abbrlinks[data.<span class="property">_id</span>];</span><br><span class="line">    <span class="keyword">if</span> (abbrlink) &#123;</span><br><span class="line">        data.<span class="property">abbrlink</span> = abbrlink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>항상 게시글 주소가 똑같이 유지되도록 <a href="https://hexo.io/api/filter#before-generate">before_generate</a> filter에서 미리 주소를 전부 계산한 다음, post_permalink filter에서는 그냥 계산한 주소를 붙이기만 하기로 했다.</p>
<p>계산한 숫자 주소는 원본 plugin에서 쓰던 대로 <strong>abbrlink</strong>라고 부르기로 했다.</p>
<p>웃기게도 가장 애먹은 부분은 모든 게시글을 불러오려면 <code>const posts = hexo.locals.get('posts').data;</code>를 써야 된다는 것을 알아내는 일이였다... 제발 documentation 똑바로 좀 만들어라...</p>
<p>이후는 abbrlink가 없는 post들을 찾은 다음, 날짜 순으로 정렬해 쓴 순더대로 abbrlink를 붙여주는게 끝이다.</p>
]]></content>
      <categories>
        <category>BLOG</category>
      </categories>
  </entry>
  <entry>
    <title>로봇은 감정을 느낄 수 있을까?</title>
    <url>/posts/4/</url>
    <content><![CDATA[<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="/images/BOOK/랑과_나의_사막.jpg"></object>
<p>랑과 나의 사막</p><p>천선란</p>
<a href="https://product.kyobobook.co.kr/detail/S000200115764"></a>
</div></div>
<p>이 소설은 주인공 랑의 죽음으로부터 시작된다. 모든 것이 멸망한 아포칼립스 세계관에서 지구는 이미 거의 모든 동식물이 사라져 황폐해진 지 오래고 인간이 노인까지 살다가 죽기에는 너무 위험한 세계가 되었다. 그렇게 끝없는 사막 속에서 랑의 엄마인 조도 죽었고, 랑도 결국 죽게 된다. 특이하게도 랑과 같이 살던 동거인은 같은 인간이 아니라 로봇인 고고였는데, 로봇이라 인간의 감정을 이해하지 못 하는 모습을 보여준다. 랑의 장례식은 아직까지 랑의 집에 남아있던 고고와 랑의 친구인 지카가 치렀는데, 고고는 지카가 왜 그렇게 허탈해하고 왜 그렇게 쓸쓸해하는지, 그리고 왜 랑의 시체를 땅속 깊이 묻어두는지 이해하지 못한다.</p>
<p>지카가 갈 곳이 없으면 같이 바다로 가자고 했을 때, 그제야 고고는 자신이 살아가야 할 목적이 없어졌다는 사실을 깨닫는다. 태어날 때부터 만들어져 목적을 가지고 살아가는 다른 로봇들과 달리, 고고의 기억은 랑이 모래 속에 파묻혀있던 자신을 구해줬을 때부터 시작된다. 어떠한 명령이나 지시도 받지 않은 채 유일하게 알고 지내던 랑이 세상의 전부였던 고고는 어떻게 할까 고민하던 도중 결국 새로운 삶의 목적을 찾지 못한 채 랑을 행복하게 해준다는 마지막 명령을 따르기 위해 랑이 가고 싶었던 과거로 가는 땅을 향한 여정을 출발하게 된다. 이 점에서 고고는 사람과 다르지 않다. 흔히들 상실을 이겨낸다고 하지만, 상실을 완전히 잊어버릴 수는 없으며 소중한 사람의 상실인 경우 이겨내지 못하고 매몰되는 경우도 생긴다. 물론 고고의 경우에는 마지막으로 하던 일을 계속해서 반복하는 것에 가까운, 완전 다른 이유로 행하는 것이지만, 그런데도 랑을 잊어버리지 못하고 랑에 대한 감정이 남아있는 것처럼 행동한다.</p>
<p>사막에서 정처 없이 떠돌던 도중 고고는 다른 로봇인 알아이아이를 만나게 된다. 알아이아이는 이미 죽어버린 주인을 기다리며 마지막 명령인 트랙터의 경로를 바꾸는 일을 수행하기 위해 트랙터에 몸을 부딪쳐가며 자신을 부숴가고 있었다. 우리가 익히 알고 있는 로봇의 모습처럼 마지막 명령을 그대로 수행하는 모습이다. 고고도 똑같은 로봇이고, 똑같이 마지막 명령을 그대로 수행하고 있지만 알아이아이를 이해하지 못 하는 모습이 인상적이다. 같은 로봇이지만, 고고가 더 효율적인 방법을 제시해주고 직접 자신의 팔을 떼주는 등 랑이 했던 것처럼 쓸데없이 오지랖이 넓은 모습은 마치 두 로봇이 서로 대화하는 장면이 아니라 사람과 로봇이 대화하는 장면처럼 보이기도 한다.</p>
<p>마지막에 도달한 과거로 가는 땅에서 만난 살리는 고고와 사람의 차이가 있는 것인지 물어본다. 그렇다. 고고가 사막으로 가는 여정을 결정한 일, 그리고 여정 중에 행동한 행위들은 사람과 다를 바가 없었다. 고고는 자신한테 감정을 느끼는 회로가 없다고 하지만, 감정은 기본적으로 실체적인 현상이 아닌 추상적인 개념이다. 인간의 감정, 기억, 생각 등도 표면적으로는 뇌 속에 있는 시냅스를 통한 전기신호일 뿐이다. 어쩌면 우리도 고고처럼 화학적인 전자회로로만 이루어진 존재라고 볼 수도 있다. 그렇다면 감정을 느낀다는 것은 무엇일까? 작가는 여기서 실제로 감정을 느끼는지 아닌지가 왜 중요하냐고 역으로 물어본다. 고고가 감정이 있는 것처럼 행동한다면 다른 사람들한테 고고가 감정을 느끼는 회로가 있는지 정말 중요하게 생각할까? 우리가 감정에 의해 행동하는 행위 그 자체가 감정을 느낀다는 근거가 되는 것이다. 애초에 감정이 추상적인 개념이기 때문에, 겉모습이 사람인지 로봇인지는 중요하지 않다. 감정이 있는 것처럼 행동한다면, 고고도 로봇임에도 불구하고 ‘인간다움’을 가지고 있다고 생각할 수 있을 것이다.</p>
]]></content>
      <categories>
        <category>BOOK</category>
        <category>소설</category>
      </categories>
  </entry>
  <entry>
    <title>무엇이든 빌려드립니다</title>
    <url>/posts/5/</url>
    <content><![CDATA[<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="/images/BOOK/외모_대여점.jpg"></object>
<p>외모 대여점</p><p>이사카와 히로치카</p>
<a href="https://product.kyobobook.co.kr/detail/S000061694206"></a>
</div></div>
<p>이 책은 하루 동안 원하는 외모를 빌릴 수 있는 외모 대여점에 방문하는 10명의 손님들에 관한 이야기다. 외모 대여점의 점장인 아즈마 안지는 사실 여우술사라 4명의 변신여우들을 다룰 수 있으며, 변신여우들은 원하는 외모로 변신할 수 있어, 변신여우들이 손님들이 원하는 외모로 변신한 뒤, 변신여우와 손님이 서로 외모를 맞바꾸는 방식으로 외모를 ‘대여’할 수 있다. 이런 소설도 나오는 것을 보면 더 잘생겨지고 싶거나 더 예뻐지고 싶은 마음은 일본에서도 한국에서도 똑같은 사람의 본성인 것 같다.</p>
<p>하지만 외모 대여점에서 자신이 가장 가지고 싶었던 외모를 빌려본 10명의 손님들은 ‘외모가 중요하지 않다’는 결론을 얻고 돌아간다. 공공장소에서 시끄럽게 떠드는 여자애들한테 조용히 하라고 말하려고 하거나, 자신이 좋아하는 남자한테 고백하려고 하거나, 혼자 있는 직장 동료에게 하고 싶은 말을 하려고 하는 등 10명의 손님들은 다양한 이유로 외모를 빌려봤지만, 정작 알아낸 것은 사람들이 ‘원하는 외모’를 빌린 자기 자신보다, 외모가 뒤바뀌어서 ‘원래 자신의 외모’를 가지고 있는 변신여우의 말을 더 잘 듣는다는 사실을 알아낸다. 외모를 빌리려고 한 손님들은 자신의 외모로는 다른 사람들한테 얘기할 수 없을 것 같아, 다른 사람들이 더 잘 들어줄 것 같은 외모를 빌려보지만, 가장 중요한 것은 자신감이 있는 외모가 아니라 자신감이 있는 내면의 모습 그 자체임을 알게 된다.</p>
<p>다만 교육적인 내용과는 별개로 소설 자체는 아쉬운 편이다. 외모 대여점은 옴니버스 형식을 사용한 소설로, 손님마다 1개의 챕터를 맡아 총 10개의 챕터로 나누어져 있는데, 책 자체가 300쪽도 안 되는 짧은 분량이기 때문에 각 손님의 이야기가 몇십 쪽 만에 끝나버려 깊은 이야기를 다루지 못 한 것 같다. 책 내용도 매번 등장인물 소개 후 외모를 바꿔본 뒤에 생각처럼 안 된다는 결론이 계속 반복되니 같은 내용만 보고 있다는 느낌도 받았다. 가장 아쉬운 점은 주인공의 얘기가 소설에 잘 안 나타난다는 점이다. 여우술사와 변신여우라는 특이한 설정을 채용했음에도 불구하고, 정작 소설 내에서의 활용도는 원하는 외모를 바꿔주는 도구로만 쓰이는 것이 대부분이다. 주인공들의 설정은 정말 매력적임에도 불구하고 그에 걸맞은 뒷이야기가 풀리지 않은 것 같아 매우 아쉽다. 아무래도 소설이 옴니버스 형식이다 보니 주인공의 이야기를 우선적으로 풀기보단, 각 챕터마다 등장하는 손님들의 이야기를 먼저 얘기하다 보니 정작 주인공에 대해 할 이야기가 줄어들어 소설에 묻힌 감이 있다. 막상 각 손님의 이야기도 손님마다 감정이입 하기에는 너무 짧아서 주인공한테도, 손님들한테도 감정을 이입할 수가 없었다. 챕터 수를 좀 더 줄이고 각 챕터를 조금 늘리면 더 나은 소설이 될 것 같다.</p>
<p>그럼에도 불구하고 워낙 소설 설정 자체가 매력적이다보니 재밌게 읽은 것 같다. 깊이 있는 소설을 원하는 사람한테는 별로지만 간단하게 읽을 수 있는 책으로는 나쁘지 않다. 몇몇 챕터는 여장남자에 관한 얘기가 나오는 등 생각해볼 만한 주제가 있는 챕터도 있었고, 전체적으로 책이 주는 교훈이 나쁘지 않다. 내가 무슨 짓을 해도 바꿀 수 없는 외모에 대해 집착하는 것보단, 내 노력으로 바꿀 수 있는 마음가짐을 바꾸는 것이 더 중요하다. 결국, 사람의 본질은 외모에 있는 것이 아니라 마음에 있다는 사실을 알게 된다.</p>
]]></content>
      <categories>
        <category>BOOK</category>
        <category>소설</category>
      </categories>
  </entry>
  <entry>
    <title>사랑을 SF적으로 표현하는 방법</title>
    <url>/posts/6/</url>
    <content><![CDATA[<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="/images/BOOK/내게_남은_사랑을_드릴게요.jpg"></object>
<p>내게 남은 사랑을 드릴게요</p><p>이유리, 김서해, 김초엽, 설재인, 천선란</p>
<a href="https://product.kyobobook.co.kr/detail/S000200755350"></a>
</div></div>
<p>이 책을 처음 봤을 때는 ‘내게 남은 사랑을 드릴게요’라는 제목과 하트로 가득 찬 표지 때문에 로맨스 소설인 줄 알았지만, 읽어보니 이 책은 사실 SF 소설 앤솔러지였다. 그런데 SF 소설 앤솔러지라고는 하지만 ‘SF 소설’은 ‘판타지 소설’처럼 너무 광범위하고 다양한 작품들을 지칭하는 말이다. 장르의 방대함을 증명하듯 이 책을 이루는 5개의 소설에서도 명확한 공통점을 찾기는 쉽지 않다. 굳이 따지자면 이 책의 제목에서도 나타나듯, ‘사랑’ 자체가 이 책을 관통하는 공통점일 것이다. 5명의 작가가 ‘SF 소설’만큼이나 정의하기 어려운 ‘사랑’을 나름의 방식대로 SF 소설로 표현한 모습을 볼 수 있었다.</p>
<p>5개의 소설 중 인상 깊었던 2개의 소설이 있는데, 먼저 김초엽 작가의 &lt;수브다니의 여름휴가&gt;가 있다. 인공장기를 배양하는 회사에서 일하던 주인공이 인공피부를 배양하는 곳에서 일한다는 내용인데, 역사가 깊은 SF 장르에서도 언급되지 않은 주제인 인공피부를 찾아내서 소설로 쓴 것을 보고 작가가 매우 똑똑하다는 생각을 했다. 또한, 인공장기는 단순히 심장을 다치면 교체하고, 눈을 다치면 교체하는 등 단순히 수술을 대체해줄 의료적인 목적만 달성한다면, 인공피부는 곰, 고양이, 용, 늑대 등 인간과 완전히 다른 종이 되고 싶은 사람들을 위해 만들어진다. 물론 피부만이 인간의 본질을 나타내는 요소는 아니겠지만, 이를 통해 ‘피부가 달라지면 우리도 인간이 아니게 되는 걸까?’라는 생각을 하도록 만든다. 이 외에도 인간과 안드로이드의 사랑과, 금속 피부를 이식받은 후 스스로 녹슬어가는 작품의 일부가 되는 결말까지, 짧은 소설임에도 불구하고 생각해볼 점이 많았다. 읽으면서도 쏟아져 내리는 새로운 설정들 때문에 이야기가 어떻게 흘러갈지 열심히 기대하면서 읽었다.</p>
<p>다음으로는 천선란 작가의 &lt;뼈의 기록&gt;이 있다. 소설 배경은 미래시대로, 안드로이드가 보급되면서 장의사 대신 장례를 치르는 장의사 안드로이드가 생겼다는 설정이다. 장의사 안드로이드인 로비스는 고독사한 노인, 자살한 여자, 사고사한 아이 등 여러 시체들의 장례를 치르며, 마지막에는 자신과 같이 말동무를 해주던 청소부 모미의 장례를 치러준다. 같은 작가의 &lt;랑과 나의 사막&gt;에서도 느낀 거지만 천선란 작가는 안드로이드 같은 기계적인 생각으로 인간의 마음을 표현하는 것을 잘하는 것 같다. 과학적인 사실인 적혈구의 기능을 얘기하면서 유가족들을 위로해주거나, 아름다움의 정의를 듣고 나서 뼈가 아름답다고 정의를 내리는 등의 모습을 보고 느꼈다. 또한, 이 소설은 발단-전개-위기-절정-결말로 이루어진 소설의 구성단계를 완벽하게 지킨 소설이기도 하다. 45페이지의 짧은 소설에 복선들도 넣어가며 우주선에서 장례를 치르는 클라이맥스로 달려가는 모습은 읽은 사람들에게 말 그대로 ‘절정’을 느끼게 해준다. 너무 짧아서 아쉬웠던 다른 소설들과 달리 짧은 글임에도 탄탄한 구성으로 이루어져 있어 수백 페이지의 소설을 다 읽은 느낌을 얻을 수 있었다.</p>
<p>이 책에서 말하는 ‘사랑’은 남녀 사이의 사랑도 있긴 하지만, 그것보다 보편적인 인간성에 관한 이야기다. 혼자서만 지내는 학우한테 먼저 다가가 친구가 돼주는 일, 가정폭력을 당하고 있는 아이한테 다가가서 안아주는 일, 애인과 만들었던 마지막 작품을 스스로 완성하는 일, 평생 볼일 없을 유가족들을 위로해주고, 함께 일하다 죽은 동료를 위해 그 마음을 헤아리고 평생 내본 적 없던 용기를 내본 일. 이 모든 것들은 인간만이 가능한 비논리적인 행동이고, 그러므로 ‘사랑’으로 밖에 표현할 말이 없다. 5명의 작가는 서로 다른 세상의 모습을 그렸지만, 그 속에서도 여전히 ‘사랑’이 존재할 것이다.</p>
]]></content>
      <categories>
        <category>BOOK</category>
        <category>소설</category>
      </categories>
  </entry>
  <entry>
    <title>사람이라면 읽어야 할 책</title>
    <url>/posts/7/</url>
    <content><![CDATA[<div class="link-grid"><div class="link-grid-container">
<object class="link-grid-image" data="/images/BOOK/일머리_문해력.jpg"></object>
<p>일머리 문해력</p><p>송숙희</p>
<a href="https://product.kyobobook.co.kr/detail/S000201077265"></a>
</div></div>
<p>세대가 지날수록 문해력이 점점 떨어지고 있다는 지적이 계속해서 나온다. ‘심심한 사과’, ‘사흘’ 등 지금까지 잘 사용되던 단어들을 이해하지 못 하는 사람들이 늘어나고 있다. 보통 이런 경우 어휘력이 문제라고 생각하는 사람들이 많다. 하지만 진짜 문제는 문해력이 부족하다는 것이다. 문해력은 ‘글을 읽고 의미를 파악하고 이해하는 능력’으로, 문해력이 높은 사람들은 읽기-생각하기-쓰기 순서로 생각하며 글을 이해하고 평가하며 사용한다. ‘심심하다’의 뜻이 ‘마음의 표현 정도가 매우 깊고 간절하다’라는 것을 아는 사람들은 그리 많지 않다. 하지만 문해력이 높은 사람들은 글의 의도를 생각하면서 읽기 때문에 ‘심심한 사과’를 보고도 사과가 지루하고 재미가 없냐면서 화를 내진 않는다.</p>
<p>OECD가 &quot;어떤 능력이 정보기술 위주의 디지털 시대에서 경쟁력을 높여줄까?&quot;라는 문제에 답하기 위해 성인 경쟁력에 대한 국제조사를 시행한 적이 있다. 이 조사에서는 특이하게도 관련 없어 보이는 문해력, 수리력, 컴퓨터를 사용한 기술적 문제해결 능력이 일하는 사람의 경쟁력을 좌우한다는 전제를 한다. 그런데 놀랍게도 문해력, 수리력, 컴퓨터를 사용한 기술적 문제해결 능력의 상관성이 강하고, 문해력이 다른 두 능력을 좌우한다는 결론이 나왔다. 컴퓨터공학부 학생으로서 왜 이런 결과가 나왔는지 생각해봤는데, 프로그래밍도 일종의 '글쓰기'라서 그런 것 같다. 같은 기능을 하는 프로그램은 다양한 방법으로 작성할 수 있지만, 프로그래머는 그중에서 다른 사람이 봤을 때 가장 읽기 쉬운 코드를 작성하려고 노력한다. 본인이 옛날에 작성한 코드를 다시 수정하거나, 다른 사람들과 같이 코드를 작성할 때 읽기 쉬운 코드일수록 이해하기가 쉽기 때문이다.</p>
<p>글쓰기도 마찬가지다. 글의 목적은 읽히는 것이다. 나 혼자만 볼 수 있고 이해할 수 있는 글이 필요한 때도 있을 수 있지만, 대부분 글은 다른 사람도 읽을 수 있도록 쓴다. 그런데 다른 사람들이 정작 내 글을 읽었을 때 이해를 못 한다면 좋은 글이 아닐 가능성이 크다. 글쓰기를 잘하는 사람은 읽는 사람 입장에서 생각할 줄 안다. 어떻게 하면 더 많은 사람이 이해할 수 있을지 생각하고, 본인의 주장을 간단하고 명료하게 주장한다. 그래서 더 효과적으로 자기의 주장을 전달할 수 있고, 다른 사람들에게 더 큰 영향력을 끼칠 수 있는 거물이 될 수 있다. 문과와 이과만큼 전혀 다른 분야인 것처럼 보이는 문해력, 수리력, 컴퓨터를 사용한 기술적 문제해결 능력이 큰 상관관계가 있는 이유다.</p>
<p>이 책은 여러 거물들의 말을 인용했다. 빌 게이츠, 워렌 버핏, 일론 머스크 등 전 세계 사람들이 알고 있는 유명인들이 모두 읽고, 생각하고, 쓰라고 권유한다. 책에서 문해력에 악영향을 끼치는 행동들을 소개해줬는데 아마 현역 군인이라면 모두 해당하는 내용일 것이다. 종이책 대신 전자책 읽기, 긴 글 대신 세줄요약 읽기, 유튜브 알고리즘에 몸을 맡기기 등 요즘 10~20대한테서 흔하게 볼 수 있는 모습이다. 심지어 세대가 지날수록 문해력이 떨어지는 것은 우리나라뿐만 아니라 전 세계에서 나타나고 있는 현상이라고 한다. 하지만 문해력은 동물이 아닌 인간이 되기 위해서 갖춰야 할 최소한의 능력이다. 단순히 보고서, 자소서, 독후감 등 글 쓸 일이 많아서 필요하다는 뜻이 아니다. 문해력은 사람이 이해하고, 생각하고, 비판적인 사고를 하기 위한 필수적인 능력이다. 남들의 생각만 따라 하는 동물 대신 스스로 생각할 수 있는 사람이 되기 위해서는 읽고, 생각하고, 쓰는 연습을 하며 문해력을 키워야 한다. 그러면 우리도 언젠가 전 세계에서 알아주는 거물이 될 수 있을 것이다.</p>
]]></content>
      <categories>
        <category>BOOK</category>
        <category>자기계발</category>
      </categories>
  </entry>
</search>
