<!doctype html><html lang=en><meta charset=UTF-8><meta content="width=device-width" name=viewport><meta content=#222 name=theme-color><meta content="Hexo 8.0.0" name=generator><link crossorigin href=https://cdnjs.cloudflare.com rel=preconnect><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css rel=stylesheet><link integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"cookiehcl.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"agate","dark":"agate"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":true,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script defer src=/js/config.js></script><meta content="Curry–Howard correspondence Functional Programming Language는 Mathematics랑 일대일 대응된다! P: T라면 T(Type)은 proposal(명제), P(Program)은 proof(증명)이라고 생각할 수 있다. 만약 type checking이 된다면, proposal에 맞는 proof가 있다는 뜻이므로" name=description><meta content=article property=og:type><meta content=Basics property=og:title><meta content=https://cookiehcl.github.io/posts/107/index.html property=og:url><meta content="기억 저장소" property=og:site_name><meta content="Curry–Howard correspondence Functional Programming Language는 Mathematics랑 일대일 대응된다! P: T라면 T(Type)은 proposal(명제), P(Program)은 proof(증명)이라고 생각할 수 있다. 만약 type checking이 된다면, proposal에 맞는 proof가 있다는 뜻이므로" property=og:description><meta content=en_US property=og:locale><meta content=2025-09-04T00:33:36.000Z property=article:published_time><meta content=2025-09-04T00:33:36.000Z property=article:modified_time><meta content=CookieHCl property=article:author><meta content=summary name=twitter:card><link href=https://cookiehcl.github.io/posts/107/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://cookiehcl.github.io/posts/107/","path":"posts/107/","title":"Basics"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Basics | 기억 저장소</title><script integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin defer src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script defer src=/js/utils.js></script><script defer src=/js/motion.js></script><script defer src=/js/sidebar.js></script><script defer src=/js/next-boot.js></script><script integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin defer src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js></script><script defer src=/js/third-party/search/local-search.js></script><script class=next-config data-name=mermaid type=application/json>{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script><script defer src=/js/third-party/tags/mermaid.js></script><script class=next-config data-name=enableMath type=application/json>true</script><link integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css rel=stylesheet><script class=next-config data-name=katex type=application/json>{"copy_tex_js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js","integrity":"sha256-Us54+rSGDSTvIhKKUs4kygE2ipA0RXpWWh0/zLqw3bs="}}</script><script defer src=/js/third-party/math/katex.js></script><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label="Toggle navigation bar" class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>기억 저장소</p> <i class=logo-line></i> </a></div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=Search role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>About</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>Tags</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>Categories</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>Archives</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>Search </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=Searching... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>Table of Contents<li class=sidebar-nav-overview>Overview</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link><span class=nav-number>1.</span> <span class=nav-text>Curry–Howard correspondence</span></a><li class="nav-item nav-level-1"><a class=nav-link><span class=nav-number>2.</span> <span class=nav-text>Rocq Calculus</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Inductive><span class=nav-number>2.1.</span> <span class=nav-text>Inductive</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Definition><span class=nav-number>2.2.</span> <span class=nav-text>Definition</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#match><span class=nav-number>2.3.</span> <span class=nav-text>match</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#apply><span class=nav-number>2.4.</span> <span class=nav-text>apply</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Compute><span class=nav-number>2.5.</span> <span class=nav-text>Compute</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%EC%97%AC%EB%8B%B4-Proof><span class=nav-number>2.6.</span> <span class=nav-text>여담) Proof</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link><span class=nav-number>3.</span> <span class=nav-text>Standard library</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#bool><span class=nav-number>3.1.</span> <span class=nav-text>bool</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#if-then-else><span class=nav-number>3.1.1.</span> <span class=nav-text>if then else</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Notation><span class=nav-number>3.2.</span> <span class=nav-text>Notation</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Constructors><span class=nav-number>3.3.</span> <span class=nav-text>Constructors</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Module><span class=nav-number>3.4.</span> <span class=nav-text>Module</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Tuples><span class=nav-number>3.5.</span> <span class=nav-text>Tuples</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Nat><span class=nav-number>3.6.</span> <span class=nav-text>Nat</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Fixpoint><span class=nav-number>3.7.</span> <span class=nav-text>Fixpoint</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#Mutual-recursion><span class=nav-number>3.7.1.</span> <span class=nav-text>Mutual recursion</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Proof><span class=nav-number>3.8.</span> <span class=nav-text>Proof</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Tactics><span class=nav-number>3.9.</span> <span class=nav-text>Tactics</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#intros><span class=nav-number>3.9.1.</span> <span class=nav-text>intros</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#simpl><span class=nav-number>3.9.2.</span> <span class=nav-text>simpl</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#reflexivity><span class=nav-number>3.9.3.</span> <span class=nav-text>reflexivity</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#induction><span class=nav-number>3.9.4.</span> <span class=nav-text>induction</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#rewrite><span class=nav-number>3.9.5.</span> <span class=nav-text>rewrite</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#destruct><span class=nav-number>3.9.6.</span> <span class=nav-text>destruct</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link><span class=nav-number>4.</span> <span class=nav-text>Rocq의 한계?</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><p class=site-author-name itemprop=name>CookieHCl<div class=site-description itemprop=description></div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>109</span> <span class=site-state-item-name>posts</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>25</span> <span class=site-state-item-name>categories</span></a></div></nav></div><div class="links-of-author animated"><span class=links-of-author-item> <a rel="noopener me" title="GitHub → https://github.com/CookieHCl" href=https://github.com/CookieHCl target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a rel="noopener me" title="BOJ → https://www.acmicpc.net/user/CookieHCl" href=https://www.acmicpc.net/user/CookieHCl target=_blank><i class="fa fa-code fa-fw"></i>BOJ</a> </span><span class=links-of-author-item> <a rel="noopener me" title="solved.ac → https://solved.ac/profile/CookieHCl" href=https://solved.ac/profile/CookieHCl target=_blank><i class="fa fa-audio-description fa-fw"></i>solved.ac</a> </span></div><div class="cc-license animated" itemprop=license><a class=cc-opacity href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ko rel=noopener target=_blank><img alt="Creative Commons" src=https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg></a></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=en><link href=https://cookiehcl.github.io/posts/107/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.gif itemprop=image> <meta content=CookieHCl itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="기억 저장소" itemprop=name> <meta itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Basics | 기억 저장소" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Basics</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>Posted on</span> <time itemprop="dateCreated datePublished" title="Created: 2025-09-04 09:33:36" datetime=2025-09-04T09:33:36+09:00>2025-09-04</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>In</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/SNU/ itemprop=url rel=index><span itemprop=name>SNU</span></a> </span> , <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/SNU/4-2/ itemprop=url rel=index><span itemprop=name>4-2</span></a> </span> , <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/SNU/4-2/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%97%84%EB%B0%80-%EA%B2%80%EC%A6%9D/ itemprop=url rel=index><span itemprop=name>소프트웨어 엄밀 검증</span></a> </span> </span><span title="Reading time" class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>Reading time ≈</span> <span>10 mins.</span> </span></div></div></header><div class=post-body itemprop=articleBody><h1>Curry–Howard correspondence</h1><p>Functional Programming Language는 Mathematics랑 일대일 대응된다!<p><code>P: T</code>라면 T(Type)은 proposal(명제), P(Program)은 proof(증명)이라고 생각할 수 있다.<br> 만약 type checking이 된다면, proposal에 맞는 proof가 있다는 뜻이므로, 명제가 참이다!<p>이걸 왜 하냐?<br> 엄밀하게 수학, 또는 프로그램의 정확성을 증명할 수 있다!<br> 특히 LLM 시대에 LLM이 내놓은 출력을 사실 믿을 수가 없는 상황임 -> 증명보조기로 검증할 수 있다면?<p>실제로 수학자들도 증명을 (Coq이 아니라 Lean을 쓰지만) 컴퓨터로 검증하고 있다!<p>더 들어가자면 T(Type)은 어떤 집합이라고 볼 수 있는데, 여기에 속한 element P(Program)을 찾을 수 있다면 T는 참이라는 뜻!<br> 반대로 T에 속한 element가 없다면 T는 거짓이다!<h1>Rocq Calculus</h1><p>Rocq에는 Type이라는 것만 존재함 (그냥 키워드임), 나머지는 전부 사용자가 정의하는 것!<br> 사실 Proposal용 Prop이랑 Value용 Set이 따로 존재하긴 하는데 일단은 둘 다 그냥 Type이라고 생각하고 무시<br> 실제로 Type이랑 똑같은데 그냥 편의상 구분해놓은 것<p>태초에는 Type이라는 것만 존재 (그냥 키워드임)<br> 나머지는 전부 사용자가 정의하는거<p><code>Type</code>은 모든 set의 set,<br> <code>MyType: Type</code>은 특정 set,<br> <code>MyElement: MyType</code>는 그 set의 element<p>모든 element는 딱 하나의 Type에만 소속되어있음!!!<br> Rocq에 subtype는 존재하지 않는다!<br> (예외로 Prop, Set은 Type의 subtype이지만 그냥 Type이라고 생각해도 됨)<br> 즉, 1이 int이면서 short이면서 bool일수는 없다는거임<h2 id=Inductive>Inductive</h2><figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>Inductive</span> day : <span class=keyword>Type</span> :=</span><br><span class=line>  | <span class=type>monday</span></span><br><span class=line>  | <span class=type>tuesday</span></span><br><span class=line>  | <span class=type>wednesday</span></span><br><span class=line>  | <span class=type>thursday</span></span><br><span class=line>  | <span class=type>friday</span></span><br><span class=line>  | <span class=type>saturday</span></span><br><span class=line>  | <span class=type>sunday</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Check</span> (day: <span class=keyword>Type</span>). <span class=comment>(* 그냥 Check day.하면 day: Set으로 뜨는데 무시!!! *)</span></span><br><span class=line><span class=keyword>Check</span> (monday: day).</span><br></pre></table></figure><p>Inductive로 set과 그 set의 element를 정의할 수 있음.<br> Check를 통해 Type 확인 가능!<p>여기서 monday는 set의 element를 정의한 것이기 때문에 <code>Check (monday: Type).</code>는 실패하게 됨<h2 id=Definition>Definition</h2><figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> next_working_day (d: day) : day :=</span><br><span class=line>  <span class=keyword>match</span> d <span class=built_in>with</span></span><br><span class=line>  | <span class=type>monday</span> => tuesday</span><br><span class=line>  | <span class=type>tuesday</span> => wednesday</span><br><span class=line>  | <span class=type>wednesday</span> => thursday</span><br><span class=line>  | <span class=type>thursday</span> => friday</span><br><span class=line>  | <span class=type>friday</span> => monday</span><br><span class=line>  | <span class=type>saturday</span> => monday</span><br><span class=line>  | <span class=type>sunday</span> => monday</span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Compute</span> (next_working_day friday). <span class=comment>(* monday: day *)</span></span><br></pre></table></figure><p>Definition으로 함수를 정의할 수 있음.<br> 프로그램을 계산했을 때 같다 = 수학에서 동치관계를 의미함.<br> e.g. <code>next_working_day friday</code>는 <code>monday</code>랑 동치!<p>하지만 프로그램이다 보니까 "계산"은 아무 동치관계로나 움직일 수 있는게 아니라 제일 단순해지는 방향으로 (즉, reduced form으로) 계산됨.<br> 즉 <code>monday</code>가 갑자기 <code>next_working_day friday</code>로 계산될 수는 없음!<p>만약 T1: Type면서 T2: Type이라면 T1->T2: Type임<br> 즉 T1->T2도 set임! T1 set에서 T2 set으로 가는 함수들의 집합을 나타냄.<br> e.g. <code>next_working_day: day -> day</code><p>Inductive처럼 T1->T2 set의 원소를 바로 만들어내고 싶다면 lambda function을 사용할 수 있음.<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>Check</span> ((<span class=keyword>fun</span> d: day => monday): day -> day).</span><br></pre></table></figure><p>사실 Definition은 엄밀히 따지면 함수를 정의하는 syntax가 아니라 lambda function에 이름 붙이는 syntax sugar임...<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> foo (b: bool): day :=</span><br><span class=line>  <span class=keyword>match</span> b <span class=built_in>with</span></span><br><span class=line>  | <span class=type>true</span> => monday</span><br><span class=line>  | <span class=type>false</span> => tuesday</span><br><span class=line>  <span class=keyword>end</span>.</span><br></pre></table></figure><p>사실 이건<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> foo: bool -> day := (</span><br><span class=line>  <span class=keyword>fun</span> b: bool =></span><br><span class=line>    <span class=keyword>match</span> b <span class=built_in>with</span></span><br><span class=line>    | <span class=type>true</span> => monday</span><br><span class=line>    | <span class=type>false</span> => tuesday</span><br><span class=line>    <span class=keyword>end</span></span><br><span class=line>).</span><br></pre></table></figure><p>이거랑 똑같음!<p>여담) syntax의 집합은 countable이지만, set에서 set으로 가는 함수의 집합은 uncountable임.<br> 즉, 수학적으로 존재하지만 우리가 Rocq로 표현할 수 없는 함수가 존재함! (그것도 uncountable 만큼이나 존재함!!)<br> 하지만 생각해보면 굳이 Rocq가 아니라 어떤 언어여도 (심지어 자연어여도) 성립하는 말이다..?<h2 id=match>match</h2><p>왠지 모르겠는데 수학에는 dual이 있어야함 (사실 수학자는 몰랐는데 컴공한테서 자연스럽게 배움)<br> Set의 element를 만들 수도 있다면 element를 없앨 수도 있어야 함?<p>프로그램을 "계산"하면 element를 없애버림.<br> 그 중 Inductive는 match로 제거함.<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>match</span> b <span class=built_in>with</span></span><br><span class=line>| <span class=type>true</span> => monday</span><br><span class=line>| <span class=type>false</span> => tuesday</span><br><span class=line><span class=keyword>end</span></span><br></pre></table></figure><ul><li>value: 계산이 완전히 끝난 값<li>expression: 계산을 하면 값이 됨</ul><p>Inductive의 value는 처음에 정의했던 값들밖에 없음!!<br> e.g. day의 value는 monday ~ sunday밖에 없음.<h2 id=apply>apply</h2><figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>Compute</span> ((<span class=keyword>fun</span> b: bool =></span><br><span class=line>        <span class=keyword>match</span> b <span class=built_in>with</span></span><br><span class=line>        | <span class=type>true</span> => monday</span><br><span class=line>        | <span class=type>false</span> => tuesday</span><br><span class=line>        <span class=keyword>end</span></span><br><span class=line>) false).</span><br></pre></table></figure><p>Function의 elimination rule은 apply임...<br> 말 그대로 <code>f x</code>하면 function을 사용한 것!<h2 id=Compute>Compute</h2><p>요약) Type에는 Inductive랑 Function이 있음<br> 각 Type마다 introduction rule이랑 elimination rule이 있음<br> 이 네 가지 rule을 type checking이 가능하도록 조합한 모든 것을 expression이라고 부름<p>Inductive의 introduction은 Inductive<br> Inductive의 elimination은 match<br> Function의 introduction은 lambda function<br> Function의 elimination은 apply (키워드는 아니지만...)<p>이제 계산을 좀 더 엄밀하게 정의할 수 있는데 같은 type(Inductive/Function)에 대해서 introduction과 elimination이 만날 경우 reduction이 일어남.<p>e.g. 아래 코드를 실행시키면<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>(<span class=keyword>fun</span> x =></span><br><span class=line>  <span class=keyword>match</span> x <span class=built_in>with</span></span><br><span class=line>  | <span class=type>monday</span> => tuesday</span><br><span class=line>  | <span class=type>tuesday</span> => wednesday</span><br><span class=line>  | <span class=type>wednesday</span> => thursday</span><br><span class=line>  | <span class=type>thursday</span> => friday</span><br><span class=line>  | <span class=type>friday</span> => monday</span><br><span class=line>  | <span class=type>saturday</span> => monday</span><br><span class=line>  | <span class=type>sunday</span> => monday</span><br><span class=line>  <span class=keyword>end</span></span><br><span class=line>) friday</span><br></pre></table></figure><p>먼저 함수 argument를 대체하고<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>match</span> friday <span class=built_in>with</span></span><br><span class=line>| <span class=type>monday</span> => tuesday</span><br><span class=line>| <span class=type>tuesday</span> => wednesday</span><br><span class=line>| <span class=type>wednesday</span> => thursday</span><br><span class=line>| <span class=type>thursday</span> => friday</span><br><span class=line>| <span class=type>friday</span> => monday</span><br><span class=line>| <span class=type>saturday</span> => monday</span><br><span class=line>| <span class=type>sunday</span> => monday</span><br><span class=line><span class=keyword>end</span></span><br></pre></table></figure><p>match를 맞추게 됨.<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>monday</span><br></pre></table></figure><h2 id=여담-Proof>여담) Proof</h2><p>이것들을 이용해서 증명을 어떻게 하냐?<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> test_next_working_day:</span><br><span class=line>  (next_working_day friday) = monday</span><br><span class=line>  :=</span><br><span class=line>  eq_refl.</span><br></pre></table></figure><p>eq_refl은 양변이 같은 등식들의 집합임.<br> 만약 <code>(next_working_day friday)</code>가 <code>monday</code>가 아니라면 eq_refl에 속하지 않으므로 type checking에 실패함!<br> 반대로 type checking이 된다면 <code>(next_working_day friday)</code>가 <code>monday</code>와 같다는게 증명이 되는 것<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>Goal</span> (next_working_day friday) = monday.</span><br><span class=line><span class=keyword>Proof</span>. <span class=built_in>simpl</span>. <span class=built_in>reflexivity</span>. <span class=keyword>Qed</span>.</span><br></pre></table></figure><p>실제 증명은 일일히 type을 지정해주는게 아니라 이런 식으로 증명하지만... 이는 후술함<h1>Standard library</h1><p>Rocq는 사실 위에 있는 네 가지 rule과 계산만으로 정의되어있음!<br> 하지만 손가락의 수명을 위해서 아주 다양한 syntax sugar들과, (e.g. Definition으로 함수 introduction)<br> 미리 정의해둔 다양한 standard library가 있음.<p>엄밀히 따지면 여기 있는 모든 내용이 standard library인건 아니긴 함;;<h2 id=bool>bool</h2><figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>Inductive</span> bool : <span class=keyword>Type</span> :=</span><br><span class=line>  | <span class=type>true</span></span><br><span class=line>  | <span class=type>false</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Definition</span> negb (b:bool) : bool :=</span><br><span class=line>  <span class=keyword>match</span> b <span class=built_in>with</span></span><br><span class=line>  | <span class=type>true</span> => false</span><br><span class=line>  | <span class=type>false</span> => true</span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line><span class=keyword>Definition</span> andb (b1:bool) (b2:bool) : bool :=</span><br><span class=line>  <span class=keyword>match</span> b1 <span class=built_in>with</span></span><br><span class=line>  | <span class=type>true</span> => b2</span><br><span class=line>  | <span class=type>false</span> => false</span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line><span class=keyword>Definition</span> orb (b1:bool) (b2:bool) : bool :=</span><br><span class=line>  <span class=keyword>match</span> b1 <span class=built_in>with</span></span><br><span class=line>  | <span class=type>true</span> => true</span><br><span class=line>  | <span class=type>false</span> => b2</span><br><span class=line>  <span class=keyword>end</span>.</span><br></pre></table></figure><p>Rocq에는 bool과 다양한 함수들이 정의되어있음.<br> 위 코드는 실제 구현을 따라한 것!<p>잠만 andb, orb는 뭐 어떻게 생겨먹은거임?<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> andb: bool -> (bool -> bool) :=</span><br><span class=line>  <span class=keyword>fun</span> b1: bool => (<span class=keyword>fun</span> b2: bool =></span><br><span class=line>    <span class=keyword>match</span> b1 <span class=built_in>with</span></span><br><span class=line>    | <span class=type>true</span> => b2</span><br><span class=line>    | <span class=type>false</span> => false</span><br><span class=line>    <span class=keyword>end</span>) : bool -> bool.</span><br></pre></table></figure><p>사실 이거랑 같은거임 bool을 받아서 bool -> bool fun을 리턴<br> 최종 타입은 bool -> bool -> bool<p>참고로 무한 루프로 빠지는 함수는 output이 수학적으로 결정이 되지 않음..<br> 그래서 Rocq는 무한 루프로 빠질 가능성이 있는 함수는 애초에 type checking을 실패하도록 만들었음!<br> (만약 항상 terminate하는 함수를 Rocq가 받아들이지 않는다면 수학적으로 항상 terminate한다는 것을 증명시켜야 type checking 가능함;;) 이러면 call by value, call by name의 결과가 똑같아서 신경 안 쓰고, 또한 reduction의 순서를 어떻게 해도 항상 같은 reduced form으로 계산됨.<p>즉, bool -> (bool -> bool)로 보든, (bool -> bool) -> bool로 보든 상관 없다는 소리!<br> 물론 실제 type checker는 단순한 프로그램이기 때문에 reduction 순서가 존재하긴 함;<p>Q) 이렇게 and를 써도 되는거 아님?<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> and1 (b1:bool) (b2:bool) :=</span><br><span class=line>  <span class=keyword>match</span> b1 <span class=built_in>with</span></span><br><span class=line>  | <span class=type>true</span> => b2</span><br><span class=line>  | <span class=type>false</span> => false</span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Definition</span> and2 (b1:bool) :=</span><br><span class=line>  <span class=keyword>match</span> b1 <span class=built_in>with</span></span><br><span class=line>  | <span class=type>true</span> => (<span class=keyword>fun</span> b2: bool => b2)</span><br><span class=line>  | <span class=type>false</span> => <span class=keyword>fun</span> <span class=keyword>_</span> => false</span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Definition</span> and3 (b1:bool) (b2:bool) :=</span><br><span class=line>  <span class=keyword>match</span> b2 <span class=built_in>with</span></span><br><span class=line>  | <span class=type>true</span> => b1</span><br><span class=line>  | <span class=type>false</span> => false</span><br><span class=line>  <span class=keyword>end</span>.</span><br></pre></table></figure><p>"사람이 보기엔" 같은 함수가 맞음<br> But 계산 방식이 다르기 때문에 Rocq가 보기엔 같은 함수가 아님...<p>정확히 말하자면 이 세 함수가 같다는 사실은 자명하지 않음<br> Rocq에서는 세 함수가 같다는 사실을 증명해야 함!<h3 id=if-then-else>if then else</h3><p>bool의 match는 Rocq에서 if then else로 바꿔줌<br> match랑 완전 똑같지만 단순 syntax sugar임<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> negb' (b:bool) : bool :=</span><br><span class=line>  <span class=keyword>if</span> b <span class=keyword>then</span> false <span class=keyword>else</span> true.</span><br><span class=line><span class=keyword>Definition</span> andb' (b1:bool) (b2:bool) : bool :=</span><br><span class=line>  <span class=keyword>if</span> b1 <span class=keyword>then</span> b2 <span class=keyword>else</span> false.</span><br><span class=line><span class=keyword>Definition</span> orb' (b1:bool) (b2:bool) : bool :=</span><br><span class=line>  <span class=keyword>if</span> b1 <span class=keyword>then</span> true <span class=keyword>else</span> b2.</span><br></pre></table></figure><p>사실 bool은 엄밀히 따지면 builtin이 아니라 standard library에 속함!<br> 그래서 if then else는 bool이 아니여도 쓸 수 있음...!! (실용성은 글쎄..)<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>Inductive</span> bw : <span class=keyword>Type</span> :=</span><br><span class=line>| <span class=type>bw_black</span></span><br><span class=line>| <span class=type>bw_white</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Definition</span> invert (x: bw) : bw :=</span><br><span class=line>  <span class=keyword>if</span> x <span class=keyword>then</span> bw_white</span><br><span class=line>  <span class=keyword>else</span> bw_black.</span><br><span class=line></span><br><span class=line><span class=keyword>Compute</span> (invert bw_black). <span class=comment>(* bw_white : bw *)</span></span><br></pre></table></figure><p>정확히 clause가 2개인 모든 Inductive는 if then else syntax를 사용할 수 있음!<br> 이때 첫 번째 clause를 true(?)로 취급함<h2 id=Notation>Notation</h2><figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>Notation</span> <span class=string>"x && y"</span> := (andb x y).</span><br><span class=line><span class=keyword>Notation</span> <span class=string>"x || y"</span> := (orb x y).</span><br><span class=line><span class=keyword>Compute</span> false |<span class=type>| false</span> |<span class=type>| true</span>. <span class=comment>(* true: bool *)</span></span><br></pre></table></figure><p>Rocq에서는 내 맘대로 syntax를 정할 수 있음!!<br> 예를 들어 위 Notation을 사용하면 다른 프로그래밍 언어처럼 &&랑 ||로 bool 값들을 계산할 수 있음!<h2 id=Constructors>Constructors</h2><figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>Inductive</span> rgb : <span class=keyword>Type</span> :=</span><br><span class=line>  | <span class=type>red</span></span><br><span class=line>  | <span class=type>green</span></span><br><span class=line>  | <span class=type>blue</span>.</span><br><span class=line><span class=keyword>Inductive</span> color : <span class=keyword>Type</span> :=</span><br><span class=line>  | <span class=type>black</span></span><br><span class=line>  | <span class=type>white</span></span><br><span class=line>  | <span class=type>primary</span> (p : rgb).</span><br></pre></table></figure><p>Inductive로부터 다른 Inductive를 정의할 수도 있음.<br> 사실 여기서 primary는 rgb->color, 즉 함수임!<p>color는 <code>black, white, primary red, primary green, primary blue</code> 5개가 있는 set이라고 생각하면 됨<br> primary라는 함수를 갖고 있는 set이라고 생각하면 안 됨!<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> isred (c : color) : bool :=</span><br><span class=line>  <span class=keyword>match</span> c <span class=built_in>with</span></span><br><span class=line>  | <span class=type>black</span> => false</span><br><span class=line>  | <span class=type>white</span> => false</span><br><span class=line>  | <span class=type>primary</span> <span class=built_in>red</span> => true</span><br><span class=line>  | <span class=type>primary</span> <span class=keyword>_</span> => false</span><br><span class=line>  <span class=keyword>end</span>.</span><br></pre></table></figure><p>이런 식으로 constructor 전체나 일부를 matching할 수 있음.<br> 사실 이것도 syntax sugar임! 원래는 Inductive에 정의된 모든 clause에 대해서 match해야 함.<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> isred (c : color) : bool :=</span><br><span class=line>  <span class=keyword>match</span> c <span class=built_in>with</span></span><br><span class=line>  | <span class=type>black</span> => false</span><br><span class=line>  | <span class=type>white</span> => false</span><br><span class=line>  | <span class=type>primary</span> p =></span><br><span class=line>      <span class=keyword>match</span> p <span class=built_in>with</span></span><br><span class=line>      | <span class=type>red</span> => true</span><br><span class=line>      | <span class=type>green</span> => false</span><br><span class=line>      | <span class=type>blue</span> => false</span><br><span class=line>      <span class=keyword>end</span></span><br><span class=line>  <span class=keyword>end</span>.</span><br></pre></table></figure><p>primary red랑 primary _를 풀어쓰면 이렇게 생겼을거임<h2 id=Module>Module</h2><figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>Module</span> Playground.</span><br><span class=line>  <span class=keyword>Definition</span> foo : rgb := blue.</span><br><span class=line><span class=keyword>End</span> Playground.</span><br><span class=line></span><br><span class=line><span class=keyword>Definition</span> foo : bool := true.</span><br><span class=line></span><br><span class=line><span class=keyword>Check</span> Playground.foo : rgb.</span><br><span class=line><span class=keyword>Check</span> foo : bool.</span><br></pre></table></figure><p>단순한 이름을 숨기는 목적을 갖고 있지만... 나중에 진짜 의미가 나온다고 함..?<h2 id=Tuples>Tuples</h2><figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>Inductive</span> bit : <span class=keyword>Type</span> :=</span><br><span class=line>  | <span class=type>B1</span></span><br><span class=line>  | <span class=type>B0</span>.</span><br><span class=line><span class=keyword>Inductive</span> nybble : <span class=keyword>Type</span> :=</span><br><span class=line>  | <span class=type>bits</span> (b0 b1 b2 b3 : bit).</span><br><span class=line></span><br><span class=line><span class=keyword>Check</span> (bits B1 B0 B1 B0): nybble.</span><br><span class=line></span><br><span class=line><span class=keyword>Definition</span> all_zero (nb : nybble) : bool :=</span><br><span class=line>  <span class=keyword>match</span> nb <span class=built_in>with</span></span><br><span class=line>  | <span class=type>(bits</span> B0 B0 B0 B0) => true</span><br><span class=line>  | <span class=type>(bits</span> <span class=keyword>_</span> <span class=keyword>_</span> <span class=keyword>_</span> <span class=keyword>_</span>) => false</span><br><span class=line>  <span class=keyword>end</span>.</span><br></pre></table></figure><p>Tuple을 사용해서 여러 Inductive가 묶여있는 타입을 정의할 수 있음.<br> c.f. 앞서 말한대로 첫 번째 clause를 true로 취급하기 때문에 Rocq에선 1 0 순서로 씀;<p>사실 이것도 syntax sugar고 match는 원래 모든 clause에 대해서 다 쓰는게 맞음...<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> all_zero' (nb : nybble) : bool :=</span><br><span class=line>  <span class=keyword>match</span> nb <span class=built_in>with</span></span><br><span class=line>  | <span class=type>(bits</span> b0 b1 b2 b3) =></span><br><span class=line>    <span class=keyword>match</span> b0 <span class=built_in>with</span></span><br><span class=line>    | <span class=type>B0</span> => <span class=keyword>match</span> b1 <span class=built_in>with</span></span><br><span class=line>            | <span class=type>B0</span> => <span class=keyword>match</span> b2 <span class=built_in>with</span></span><br><span class=line>                    | <span class=type>B0</span> => <span class=keyword>match</span> b3 <span class=built_in>with</span></span><br><span class=line>                            | <span class=type>B0</span> => true</span><br><span class=line>                            | <span class=type>B1</span> => false</span><br><span class=line>                            <span class=keyword>end</span></span><br><span class=line>                    | <span class=type>B1</span> => false</span><br><span class=line>                    <span class=keyword>end</span></span><br><span class=line>            | <span class=type>B1</span> => false</span><br><span class=line>            <span class=keyword>end</span></span><br><span class=line>    | <span class=type>B1</span> => false</span><br><span class=line>    <span class=keyword>end</span></span><br><span class=line>  <span class=keyword>end</span>.</span><br></pre></table></figure><h2 id=Nat>Nat</h2><p>Problem) 지금은 유한한 set밖에 못 만듦<br> 자연수같은 무한한 set은 어떻게 만듦?<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>Inductive</span> nat: <span class=keyword>Type</span> :=</span><br><span class=line>  | <span class=type>O</span></span><br><span class=line>  | <span class=type>S</span> (n : nat).</span><br></pre></table></figure><p>Rocq에서는 nat으로 자연수를 정의하고 있음.<br> 0은 O, 1은 S O, 2는 S S O, ...<p>lambda calculus에서 자연수를 정의했던 방식이랑 비슷함!<br> c.f. <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>n</mi><mo>=</mo><mi>λ</mi><mi>f</mi><mi mathvariant=normal>.</mi><mi>λ</mi><mi>x</mi><mi mathvariant=normal>.</mi><msup><mi>f</mi><mi>n</mi></msup><mo stretchy=false>(</mo><mi>x</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>n = \lambda f. \lambda x. f^n(x)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.4306em;></span><span class="mord mathnormal">n</span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class="mord mathnormal">λ</span><span class="mord mathnormal" style=margin-right:0.10764em;>f</span><span class=mord>.</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class=mord>.</span><span class=mord><span class="mord mathnormal" style=margin-right:0.10764em;>f</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:0.6644em;><span style=top:-3.063em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class=mopen>(</span><span class="mord mathnormal">x</span><span class=mclose>)</span></span></span></span><p>자연수는 너무 많이 쓰이기 때문에 특별하게 자연수는 알아서 계산해서 보여줌<br> 예를 들어 <code>Check (S (S (S (S O)))).</code>는 알아서 <code>4 : nat</code>로 계산해서 나옴.<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>Set</span> <span class=keyword>Printing</span> <span class=keyword>All</span>.</span><br><span class=line><span class=keyword>Check</span> <span class=number>5.</span> <span class=comment>(* S (S (S (S (S O)))) *)</span></span><br></pre></table></figure><p>이게 싫다면 <code>Set Printing All.</code>으로 syntax sugar를 꺼버릴 수 있다...<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>Inductive</span> nat: <span class=keyword>Type</span> :=</span><br><span class=line>  | <span class=type>O</span></span><br><span class=line>  | <span class=type>S</span> (n : nat).</span><br><span class=line></span><br><span class=line><span class=keyword>Inductive</span> otherNat: <span class=keyword>Type</span> :=</span><br><span class=line>  | <span class=type>baba</span></span><br><span class=line>  | <span class=type>fofo</span> (jiji : otherNat).</span><br></pre></table></figure><p>사실 위의 otherNat이랑 nat은 같은 집합이지만 Rocq는 두 집합이 같다는 증명을 할 수가 없음...<br> 심지어 otherNat이랑 nat이 다르다는 증명도 할 수가 없음!<br> Rocq에서는 두 집합이 같다는 증명을 할 수 없다는게 증명되어있음!<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> pred (n : nat) : nat :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => O</span><br><span class=line>  | <span class=type>S</span> n' => n'</span><br><span class=line>  <span class=keyword>end</span>.</span><br></pre></table></figure><p>-1은 이렇게 정의되어 있음<br> <s>음수는 일단 나중에</s><p>c.f. S도 따지고 보면 nat -> nat인데 +1의 역할을 하는 것 아니냐?<br> 하지만 pred와 S는 조금 다른데 pred는 계산을 하는 함수지만 S는 그냥 element를 만드는 정의임.<br> 사실 S는 애초에 계산을 하지도 않음! (e.g. S O는 더 이상 reduce할 수 없음)<p>아래에서 설명하는 Fixpoint를 쓰면 덧셈 뺄셈 등등도 정의할 수 있음! <code>n m: nat</code>은 같은 타입 인자 여러 개를 한번에 정의시켜주는 syntax sugar임<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br></pre><td class=code><pre><span class=line><span class=keyword>Fixpoint</span> plus (n m : nat) : nat :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => m</span><br><span class=line>  | <span class=type>S</span> n' => S (plus n' m)</span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Compute</span> (plus <span class=number>3</span> <span class=number>4</span>).</span><br><span class=line></span><br><span class=line><span class=keyword>Fixpoint</span> minus (n m : nat) : nat :=</span><br><span class=line>  <span class=keyword>match</span> n, m <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span>, <span class=keyword>_</span> => O</span><br><span class=line>  | <span class=type>n</span>, O => n</span><br><span class=line>  | <span class=type>S</span> n', S m' => minus n' m'</span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Compute</span> (minus <span class=number>6</span> <span class=number>2</span>).</span><br><span class=line></span><br><span class=line><span class=keyword>Fixpoint</span> mult (n m : nat) : nat :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => O</span><br><span class=line>  | <span class=type>S</span> n' => plus m (mult n' m)</span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Compute</span> (mult <span class=number>3</span> <span class=number>3</span>).</span><br><span class=line></span><br><span class=line><span class=keyword>Fixpoint</span> exp (base power : nat) : nat :=</span><br><span class=line>  <span class=keyword>match</span> power <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => S O</span><br><span class=line>  | <span class=type>S</span> p => mult base (exp base p)</span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Compute</span> (exp <span class=number>2</span> <span class=number>10</span>).</span><br><span class=line></span><br><span class=line><span class=keyword>Notation</span> <span class=string>"x + y"</span> := (plus x y)</span><br><span class=line>                       (<span class=built_in>at</span> level <span class=number>50</span>, <span class=built_in>left</span> associativity)</span><br><span class=line>                       : nat_scope.</span><br><span class=line><span class=keyword>Notation</span> <span class=string>"x - y"</span> := (minus x y)</span><br><span class=line>                       (<span class=built_in>at</span> level <span class=number>50</span>, <span class=built_in>left</span> associativity)</span><br><span class=line>                       : nat_scope.</span><br><span class=line><span class=keyword>Notation</span> <span class=string>"x * y"</span> := (mult x y)</span><br><span class=line>                       (<span class=built_in>at</span> level <span class=number>40</span>, <span class=built_in>left</span> associativity)</span><br><span class=line>                       : nat_scope.</span><br><span class=line><span class=keyword>Compute</span> ((<span class=number>1</span> + <span class=number>3</span> - <span class=number>2</span>) * <span class=number>5</span>).</span><br></pre></table></figure><p>(Notation 뒤쪽에 나오는건 연산자 우선순위, 연산 방향 같은거 정의해준거임)<br> 등호나 부등호도 두 nat을 받아서 bool을 내놓는 함수로 정의할 수 있음!<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>Fixpoint</span> eqb (n m : nat) : bool :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => <span class=keyword>match</span> m <span class=built_in>with</span></span><br><span class=line>         | <span class=type>O</span> => true</span><br><span class=line>         | <span class=type>S</span> m' => false</span><br><span class=line>         <span class=keyword>end</span></span><br><span class=line>  | <span class=type>S</span> n' => <span class=keyword>match</span> m <span class=built_in>with</span></span><br><span class=line>            | <span class=type>O</span> => false</span><br><span class=line>            | <span class=type>S</span> m' => eqb n' m'</span><br><span class=line>            <span class=keyword>end</span></span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Fixpoint</span> leb (n m : nat) : bool :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => true</span><br><span class=line>  | <span class=type>S</span> n' =></span><br><span class=line>      <span class=keyword>match</span> m <span class=built_in>with</span></span><br><span class=line>      | <span class=type>O</span> => false</span><br><span class=line>      | <span class=type>S</span> m' => leb n' m'</span><br><span class=line>      <span class=keyword>end</span></span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Notation</span> <span class=string>"x =? y"</span> := (eqb x y) (<span class=built_in>at</span> level <span class=number>70</span>) : nat_scope.</span><br><span class=line><span class=keyword>Notation</span> <span class=string>"x &lt;=? y"</span> := (leb x y) (<span class=built_in>at</span> level <span class=number>70</span>) : nat_scope.</span><br><span class=line><span class=keyword>Compute</span> (<span class=number>4</span> &lt;=? <span class=number>2</span>).</span><br></pre></table></figure><h2 id=Fixpoint>Fixpoint</h2><p>Fixpoint를 쓰면 Definition과 달리 재귀함수를 정의할 수 있음.<br> Definition은 계산을 한 번만 하지만 Fixpoint는 계산을 몇 번 할지 모름!<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>Fixpoint</span> even (n:nat) : bool :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => true</span><br><span class=line>  | <span class=type>S</span> O => false</span><br><span class=line>  | <span class=type>S</span> (S n') => even n'</span><br><span class=line>  <span class=keyword>end</span>.</span><br></pre></table></figure><p>Q) 그냥 Fixpoint만 쓰면 안 됨?<br> A) 그냥 Readability 용도임 전부 Fixpoint로 써도 되긴 하는데 Definition이라고 쓰면 재귀가 없다는게 확실해짐<br> c.f. Inductive에도 비슷한게 있음... 사실 Inductive가 Fixpoint에 가까운 형태임!<br> Variant는 Inductive랑 똑같지만 Definition처럼 재귀를 허용하지 않는 형태임. (nat 같은 것 정의 불가)<p>Fixpoint도 syntax sugar지만... 굳이 lambda function 형태로 재귀함수를 쓰고 싶다면 fun 대신 fix를 쓰고 알 수 없는 이유로 반드시 :=를 써야 함<br> 재귀함수의 함수명은 아무거나 써도 되지만 관례상 self를 쓴다고 함<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>Compute</span> (<span class=built_in>fix</span> self n :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => true</span><br><span class=line>  | <span class=type>S</span> O => false</span><br><span class=line>  | <span class=type>S</span> (S n') => self n'</span><br><span class=line>  <span class=keyword>end</span>) <span class=number>5.</span></span><br></pre></table></figure><p>참고로 앞서 말한대로 Rocq 함수는 반드시 끝나야함<br> 아래 함수는 Rocq이 보기에 안 끝날 수도 있는 함수라 reject됨<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>Fixpoint</span> even (n:nat) : bool :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => true</span><br><span class=line>  | <span class=type>S</span> O => false</span><br><span class=line>  | <span class=type>S</span> (S n') => even (S (S n'))</span><br><span class=line>  <span class=keyword>end</span>.</span><br></pre></table></figure><p>하지만 당연히 끝나는 함수도 Rocq이 멍청해서 안 끝난다고 판단할 수도 있음...<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>(* 외않됨 *)</span></span><br><span class=line></span><br><span class=line><span class=keyword>Fixpoint</span> iszero (n:nat) : bool :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => true</span><br><span class=line>  | <span class=type>S</span> O => false</span><br><span class=line>  | <span class=type>S</span> (S n') => iszero (S n')</span><br><span class=line>  <span class=keyword>end</span>.</span><br></pre></table></figure><p>하지만 모든 끝나는 함수는 Rocq가 끝난다는 것을 알 수 있게 만들 수 있다는 증명이 있다고 함?<h3 id=Mutual-recursion>Mutual recursion</h3><figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>Fixpoint</span> even (n: nat) : bool :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => true</span><br><span class=line>  | <span class=type>S</span> n' => odd n'</span><br><span class=line>  <span class=keyword>end</span></span><br><span class=line><span class=built_in>with</span> odd (n: nat) : bool :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => false</span><br><span class=line>  | <span class=type>S</span> n' => even n'</span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Compute</span> (even <span class=number>4</span>).</span><br></pre></table></figure><p>Mutual recursion도 가능함! with를 써서 두 함수를 동시에 정의할 수 있음.<br> 만약 even만 정의하고 싶고 odd는 숨기고 싶다면 let in을 써야함<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>Fixpoint</span> even (n: nat) : bool :=</span><br><span class=line>  <span class=keyword>let</span> odd := (<span class=built_in>fix</span> self n := <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>    | <span class=type>O</span> => false</span><br><span class=line>    | <span class=type>S</span> n' => even n'</span><br><span class=line>    <span class=keyword>end</span>)</span><br><span class=line>  <span class=built_in>in</span></span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => true</span><br><span class=line>  | <span class=type>S</span> n' => odd n'</span><br><span class=line>  <span class=keyword>end</span>.</span><br></pre></table></figure><p>물론 mutual recursion은 syntax sugar라서 없애버릴수는 있긴 함...<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> _even (odd: nat -> bool) (n: nat) : bool :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => true</span><br><span class=line>  | <span class=type>S</span> n' => odd n'</span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line><span class=keyword>Definition</span> _odd (even: nat -> bool) (n: nat) : bool :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span> => false</span><br><span class=line>  | <span class=type>S</span> n' => even n'</span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line><span class=keyword>Fixpoint</span> even (n: nat) : bool :=</span><br><span class=line>  _even (_odd even) n.</span><br><span class=line><span class=keyword>Fixpoint</span> odd (n: nat) : bool :=</span><br><span class=line>  _odd (_even odd) n.</span><br></pre></table></figure><p>좀 더 현실적인 방법으로는 일반적으로 tuple로 묶어서 recursion을 동시에 돌리는 방법이 있음<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>Fixpoint</span> evenodd (n : nat) : bool * bool :=</span><br><span class=line>  <span class=keyword>match</span> n <span class=built_in>with</span></span><br><span class=line>  | <span class=type>O</span>     => (true, false)</span><br><span class=line>  | <span class=type>S</span> n'  =></span><br><span class=line>    <span class=keyword>match</span> evenodd n' <span class=built_in>with</span></span><br><span class=line>    | <span class=type>(e</span>, o) => (o, e)</span><br><span class=line>    <span class=keyword>end</span></span><br><span class=line>  <span class=keyword>end</span>.</span><br><span class=line></span><br><span class=line><span class=keyword>Definition</span> even (n : nat) : bool := fst (evenodd n).</span><br><span class=line><span class=keyword>Definition</span> odd  (n : nat) : bool := snd (evenodd n).</span><br></pre></table></figure><h2 id=Proof>Proof</h2><p>Rocq에선 놀랍게도 1+1 = 2를 간단하게 증명할 수 있음!<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>Example</span> plus_1_1 : <span class=number>1</span> + <span class=number>1</span> = <span class=number>2.</span></span><br><span class=line><span class=keyword>Proof</span>. <span class=built_in>reflexivity</span>. <span class=keyword>Qed</span>.</span><br></pre></table></figure><p>이게 왜 증명임?<br> 사실 아래랑 같은 말임<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> plus_1_1' : <span class=number>1</span> + <span class=number>1</span> = <span class=number>2</span> := eq_refl.</span><br></pre></table></figure><p>즉, 위에서 쓴 Proof는 사실 type checking 과정임!<br> 하지만 사람이 조금이라도 더 알아먹기 쉽게 Proof와 tactic들로 증명하게 하는 것.<p>Rocq에서 =는 사실 Inductive로 정의된 set(+ Notation)으로, <code>1 + 1 = 2</code>는 사실 <code>@eq nat (1 + 1) 2</code>임.<br> <code>Print eq.</code>로 정의를 보면 아래처럼 나와있음.<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>Inductive</span> eq (A : <span class=keyword>Type</span>) (x : A) : A -> <span class=keyword>Prop</span> :=</span><br><span class=line>| <span class=type>eq_refl</span> : eq A x x.</span><br></pre></table></figure><p>사실 이 Inductive는 지금까지 본 Inductive보다 더 general한 버전인 Inductive family임.<br> A -> Prop이라는건 임의의 A를 받아서 Prop을 내놓는다는 거임. (Prop은 대충 Type이라고 생각하자)<br> 즉 <code>eq nat 1 1</code>, <code>eq nat 1 2</code> 이런건 전부 Type임! 다른 언어의 Generics처럼 Inductive family로 수많은 Type을 한번에 정의했다고 생각해도 됨.<br> 근데 이 Inductive의 construct은 <code>eq_refl: eq A x x</code>밖에 없기 때문에 <code>eq nat 1 1</code>의 element는 construct할 수 있는데 <code>eq nat 1 2</code>의 element는 construct할 수 없음.<br> 즉 <code>1 = 1</code>은 참이지만 <code>1 = 2</code>는 거짓이다!<p>위 정의를 좀 더 쉽게 바꾸면<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>Inductive</span> eq' (A : <span class=keyword>Type</span>) : A -> A -> <span class=keyword>Type</span> :=</span><br><span class=line>| <span class=type>eq_refl</span> (x: A) : eq' A x x.</span><br></pre></table></figure><p>eq는 어떤 set A가 주어졌을 때, A의 element 두 개를 받고 set을 내놓는거라고 볼 수 있음<br> 근데 construct가 eq_refl밖에 없으므로 주어진 두 element가 똑같을 때만 construct 됨.<br> <code>eq A a b</code>는 a, b가 같다면 원소가 있는 set, a, b가 다르다면 원소가 없는 set이 된다!<p>그럼 a와 b가 같다는 증명은 어떻게 하냐? 실제로 원소가 있다는 것을 보여주면 됨.<br> Rocq 식으로 표현하면 <code>eq A a b</code> 타입인 element를 찾으면 되는거고,<br> 더 일반적으로는 Proposition 타입인 Proof를 만들면 Proposition이 참이라는 것을 증명한 것임.<br> 즉, 단순한 type checking으로 증명할 수 있고, "증명을 코딩"한다는건 Proof를 type checking 통과하도록 코딩한다는 소리임.<p>이렇게 보면 뭔가 특별해보이지만 사실 type checking rule은 아래 세 가지 경우에서 모두 똑같음! 지금까지 우리가 쓰던 type checking rule을 Set, Prop, Type에서 똑같이 사용함.<br> 다만 용도를 조금 구분하기 위해 Rocq 내부적으로는 Set이랑 Prop이라는 새로운 Type을 만들어서 사용중임.<ul><li>element: Set<li>proof: Prop<li>program: Type</ul><figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> plus_2_2 : <span class=number>2</span>+<span class=number>2</span> = <span class=number>4</span> := @eq_refl nat <span class=number>4.</span></span><br><span class=line><span class=keyword>Definition</span> plus_2_2' : @eq nat (<span class=number>2</span>+<span class=number>2</span>) <span class=number>4</span> := @eq_refl nat <span class=number>4.</span></span><br></pre></table></figure><p>예시로 2+2 = 4를 보면 (@eq랑 =는 같은거임) <code>2+2 = 4</code>는 2+2 = 4가 맞다는 set인데, <code>@eq_refl nat 4</code>가 이 set의 element로 type checking됐다는 소리는 <code>2+2 = 4</code>라는 set에 원소가 있다는거임.<br> 근데 앞서 말했던대로 set에 원소가 있다는거 자체가 <code>2+2 = 4</code>는 참이라는거임.<br> 즉, type checking이 성공했다는 것 자체가 <code>2+2 = 4</code>는 참이라는 증명이다!<p>c.f. A랑 B가 둘다 C로 reduction이 되면 A, B는 convertable하다고 함. (서로 바꿀 수 있다)<br> Rocq에서 계산이 되는 경우 reduction은 알아서 해줘서 2+2는 알아서 4가 됨<br> 사실 우리는 4 = 4를 증명하고 있었던 것;;<p>c.f. <code>Definition what: 1+1 = 3 := 1+1 = 3.</code> 같은건 올바른 증명이 아님!!<br> <code>1+1 = 3 : Type</code>이고, <code>what: 1+1 = 3</code>임. Element와 Type은 다르다!<br> 당연히 Type은 Type의 element일 수가 없음 (<code>2: nat</code>이지 <code>nat: nat</code>이 아니다..)<p>Q. <code>1+1 = 2</code>, <code>2+2 = 4</code> 같은 걸 쓸 때마다 계속 타입을 만듦?<br> A. 그건 C, Rust같이 어셈블리 만들어야 하는 애들이나 그러는거고 functional language는 물론이고, C나 Rust도 type checking 과정에선 polynomial type 상태를 유지하면서 type checking 가능함 (심지어 아래에 나오는 forall 같은 경우도 type checking이 됨!)<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>(* 이건 Typechecking 안 됨 *)</span></span><br><span class=line><span class=keyword>Definition</span> foo (n: nat) : (n + <span class=number>1</span>) = (<span class=number>1</span> + n) := @eq_refl nat (S n).</span><br></pre></table></figure><p>위에껀 non-trivial함!<br> <code>1 + n</code>은 <code>S n</code>으로 reduction이 되긴 하지만, <code>n + 1</code>은 n을 몰라서 reduction이 안 됨<br> 그래서 같다는게 trivial하지 않아서 증명이 안 됨..<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>Lemma</span> bar (n : nat) : n + <span class=number>1</span> = <span class=number>1</span> + n.</span><br><span class=line><span class=keyword>Proof</span>.</span><br><span class=line>  <span class=built_in>induction</span> n.</span><br><span class=line>  - <span class=built_in>simpl</span>. <span class=built_in>reflexivity</span>.</span><br><span class=line>  - <span class=built_in>simpl</span>. <span class=built_in>rewrite</span> IHn. <span class=built_in>simpl</span>. <span class=built_in>reflexivity</span>.</span><br><span class=line><span class=keyword>Qed</span>.</span><br></pre></table></figure><p>그래서 이렇게 수학적 귀납법을 써서 증명해야 함.<br> 이게 우리가 일반적으로 Rocq에서 증명하는 과정임!<ul><li>Lemma, Example, Theorem, Goal 등등은 전부 똑같은 keyword임; 증명하고 싶은 명제를 정의해줌 (Goal은 이름을 지정할 수 없다는 차이점이 있음)<li>Proof는 지금부터 명제를 증명할 프로그램을 짜겠다는 소리<li>induction, simpl, reflexivity 같은 tactic으로 프로그램을 작성함<li>Qed는 완성한 프로그램을 type checking 해서 맞는지 검사함.</ul><p>Proof ~ Qed는 우리가 <code>@eq_refl nat 4</code>로 짜던 프로그램을 Rocq가 대신 짜주는 거라고 생각하면 됨.<p>e.g. simpl.이라는 tactic은 제일 단순한 형태로 reduction시킴<br> 예를 들어 <code>2+2 = 4</code>라는 goal을 <code>4 = 4</code>로 만듦<br> 정확히 말하면 기존 goal을 수정하는게 아니라 더 쉬운 goal을 증명하면 기존 goal을 증명할 수 있게 해주는거임!<br> 즉, simpl.이란 tactic은 <code>q: 4 = 4</code>를 만족하는 q가 있다면 q를 사용해서 <code>p: 2+2 = 4</code>를 만족하는 p를 만들어주는 tactic임.<br> 사실 reduction은 항상 하기 때문에 simpl.은 안 써도 되는 tactic이지만 사람이 알아보기 편하게 사용함..<p>실제로 만들어진 프로그램을 보고 싶으면 <code>Print bar.</code>를 해보면 됨!<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>Print</span> bar.</span><br><span class=line></span><br><span class=line><span class=comment>(*</span></span><br><span class=line><span class=comment>bar =</span></span><br><span class=line><span class=comment>fun n : nat =></span></span><br><span class=line><span class=comment>nat_ind (fun n0 : nat => n0 + 1 = 1 + n0) (eq_refl : 0 + 1 = 1 + 0)</span></span><br><span class=line><span class=comment>(fun (n0 : nat) (IHn : n0 + 1 = 1 + n0) => eq_ind_r (fun n1 : nat => S n1 = S (S n0)) (eq_refl : S (1 + n0) = S (S n0)) IHn :</span></span><br><span class=line><span class=comment>S n0 + 1 = 1 + S n0) n</span></span><br><span class=line><span class=comment>     : forall n : nat, n + 1 = 1 + n</span></span><br><span class=line><span class=comment>*)</span></span><br></pre></table></figure><p>좀 더 알아듣기 쉽게 만들려면 unfold로 풀어쓸 수 있음.<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=keyword>Lemma</span> bar (n : nat) : n + <span class=number>1</span> = <span class=number>1</span> + n.</span><br><span class=line><span class=keyword>Proof</span>.</span><br><span class=line>  <span class=built_in>induction</span> n.</span><br><span class=line>  - <span class=built_in>simpl</span>. <span class=built_in>reflexivity</span>.</span><br><span class=line>  - <span class=built_in>simpl</span>. <span class=built_in>rewrite</span> IHn. <span class=built_in>simpl</span>. <span class=built_in>reflexivity</span>.</span><br><span class=line><span class=keyword>Defined</span>.</span><br><span class=line><span class=comment>(* Defined로 끝내면 추후에 증명 내용을 사용할 수 있음. *)</span></span><br><span class=line></span><br><span class=line><span class=keyword>Goal</span> bar = bar.</span><br><span class=line><span class=built_in>unfold</span> bar <span class=built_in>at</span> <span class=number>1.</span></span><br><span class=line><span class=built_in>unfold</span> nat_ind.</span><br><span class=line><span class=built_in>unfold</span> eq_ind_r.</span><br><span class=line><span class=built_in>unfold</span> eq_ind.</span><br><span class=line><span class=built_in>unfold</span> eq_sym.</span><br><span class=line><span class=comment>(* Set Printing All. 쓰면 syntax sugar 다 없애버림 *)</span></span><br><span class=line></span><br><span class=line><span class=comment>(*</span></span><br><span class=line><span class=comment>(fun n : nat =></span></span><br><span class=line><span class=comment>  (fix F (n0 : nat) : n0 + 1 = 1 + n0 :=</span></span><br><span class=line><span class=comment>  match n0 as n1 return (n1 + 1 = 1 + n1) with</span></span><br><span class=line><span class=comment>  | 0 => eq_refl</span></span><br><span class=line><span class=comment>  | S n1 => match match F n1 in ([...]) return ([...]) with</span></span><br><span class=line><span class=comment>      | eq_refl => eq_refl</span></span><br><span class=line><span class=comment>      end in (_ = a) return (S a = S (S n1)) with</span></span><br><span class=line><span class=comment>    | eq_refl => eq_refl</span></span><br><span class=line><span class=comment>    end</span></span><br><span class=line><span class=comment>  end) n) = bar</span></span><br><span class=line><span class=comment>*)</span></span><br></pre></table></figure><p>참고로<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>Definition</span> even (n: nat) : <span class=keyword>Type</span> :=</span><br><span class=line>  <span class=built_in>exists</span> m: nat, n = <span class=number>2</span> * m.</span><br></pre></table></figure><p>이렇게 하면 명제를 사용해서 성질을 나타낼 수가 있음!!<br> 정확히 말하자면 <code>even n</code>은 n이 짝수라는 명제를 나타냄<br> <code>even 4</code>를 증명하면 4가 짝수라는 것을 나타낼 수 있음!<p>exists는 조건을 만족하는 m들의 집합을 나타냄<br> 즉, 여기서 even은 <code>n = 2 * m</code>을 만족하는 m들의 집합으로 정의됨.<br> 명제는 element가 있다면 참, 없다면 거짓이므로 <code>n = 2 * m</code>인 m이 있다면 <code>even n</code>은 참이 됨!<h2 id=Tactics>Tactics</h2><p>아래 예제를 통해 다른 tactic들에 대해 알아보자!<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>Theorem</span> plus_0_n : <span class=keyword>forall</span> n : nat, <span class=number>0</span> + n = n.</span><br><span class=line><span class=keyword>Proof</span>.</span><br><span class=line>  <span class=built_in>intros</span> n. <span class=built_in>simpl</span>. <span class=built_in>reflexivity</span>.</span><br><span class=line><span class=keyword>Qed</span>.</span><br></pre></table></figure><p>참고로 Require Import Utf8. 써주면 ∀로 forall을 대체할 수 있음!<br> e.g. <code>Theorem plus_0_n : ∀ n : nat, 0 + n = n.</code><br> fun도 <code>λ</code>로 바뀌고 =>도 <code>⇒</code>로 바뀌고 생각보다 유니코드로 바뀌는게 많음...<p>아니 근데 forall은 뭔데??<br> 사실 그냥 function임 <code>(n : nat) -> 0 + n = n</code><br> 근데 우리가 알던 function <code>A -> B</code>랑 다른게 뭐냐?<br> 우리가 지금까지 쓰던 <code>A -> B</code>는 non-dependent function; input/return type이 항상 같음<br> 근데 <code>(n : nat) -> 0 + n = n</code>은 dependent function; input에 따라 return type이 다름!!<br> e.g. 1을 넣으면 return type은 <code>0 + 1 = 1</code>!<p>하여튼 <code>(n : nat) -> 0 + n = n</code>은 nat을 받아서 <code>0 + n = n</code>의 element를 내놓는 (즉 <code>0 + n = n</code>의 증명을 내놓는) 함수들의 집합임.<br> 즉 <code>plus_0_n : (n : nat) -> 0 + n = n</code>이라는 프로그램이 있다면 이 집합에 속하는 element <code>plus_0_n</code>이 있다; 즉 이 집합은 공집합이 아니다; 즉 이 명제(모든 n에 대해서 0+n = n이다)를 증명할 수 있다!<br> <s>사실 이거 n+0이면 non trivial해서 바로 증명 안 됨</s><h3 id=intros>intros</h3><p><code>intros n.</code>은 n을 fix시켜놓고 어떤 fix된 n 하나에 대해서 goal을 보이도록 만듦. 사실상 forall을 풀어주는 역할!<p>위 예시에선 n이 변수로 올라오고 goal은 <code>0+n = n</code>만 증명하면 됨<p>(단순히 forall만 풀어주는건 아니고 <code>p -> q</code>의 경우 가정 p를 올려주는 등 더 다양한 사용처가 있음)<h3 id=simpl>simpl</h3><p>앞서 봤던대로 simpl은 reduction을 알아서 해주는 역할, Rocq는 항상 reduction을 하기 때문에 안 써도 아무 문제 없음!<p>순수하게 사람이 알아보기 편하라고 만들어진 tactic임;<br> 만약 너무 한번에 reduction이 돼서 이해하기가 어렵다면 <code>simpl Nat.eqb.</code>처럼 단계별로 reduction을 할 수 있음.<h3 id=reflexivity>reflexivity</h3><p>지금까지 봤던 eq_refl을 만들어주는 역할!<br> 등호 양변이 같으면 goal을 풀어버림<h3 id=induction>induction</h3><figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>Theorem</span> plus_n_0: <span class=keyword>forall</span> n: nat, n + <span class=number>0</span> = n.</span><br><span class=line><span class=keyword>Proof</span>.</span><br><span class=line>  <span class=built_in>intros</span> n.</span><br><span class=line>  <span class=built_in>induction</span> n.</span><br><span class=line>  - <span class=built_in>simpl</span>. <span class=built_in>reflexivity</span>.</span><br><span class=line>  - <span class=built_in>simpl</span>. <span class=built_in>rewrite</span> IHn. <span class=built_in>reflexivity</span>.</span><br><span class=line><span class=keyword>Qed</span>.</span><br></pre></table></figure><p><code>0+n</code>은 simpl.이 먹히지만 <code>n+0</code>은 simpl.이 안 먹힘..<br> 이 경우 induction으로 수학적 귀납법을 써야 함!<p>induction n을 하면 2개의 subgoal을 만들어 냄<ol><li>n = 0일때 성립<li>n 일때 성립하면 S n에서 성립</ol><p>subgoal을 증명하고 싶으면 <code>-</code>를 사용해서 subgoal을 하나씩 증명할 수 있음.<br> c.f. subgoal 단계가 깊어지면 <code>+</code>, <code>*</code>, <code>--</code>, <code>++</code>, <code>**</code>를 쓰거나 다른 프로그래밍 언어처럼 중괄호를 여닫는 식으로 subgoal을 표시할 수 있음.<br> 아니면 아예 subgoal이 너무 많다면 <code>;</code>를 사용해서 모든 subgoal마다 똑같은 tactic을 사용해서 증명하라고 할 수 있음!<h3 id=rewrite>rewrite</h3><p>rewrite는 등식을 바꿔주는 tactic임.<p>위에서 induction을 하면 두 번째 subgoal에서 귀납가정이 (n일때 <code>n + 0 = n</code>이 성립) IHn이라는 이름으로 생기는데,<br> <code>rewrite IHn.</code>은 귀납가정을 사용해서 n + 0을 n으로 바꾸라는 소리임.<p>기본적으로 <code>rewrite H.</code>는 왼쪽에서 오른쪽으로 치환하지만,<br> <code>rewrite &lt;- H.</code>로 쓰면 오른쪽에서 왼쪽으로 치환해줌.<h3 id=destruct>destruct</h3><figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>Notation</span> <span class=string>"x =? y"</span> := (Nat.eqb x y) (<span class=built_in>at</span> level <span class=number>70</span>) : nat_scope.</span><br><span class=line></span><br><span class=line><span class=keyword>Theorem</span> plus_1_neq_0: <span class=keyword>forall</span> n: nat,</span><br><span class=line>  ((n + <span class=number>1</span>) =? <span class=number>0</span>) = false.</span><br><span class=line><span class=keyword>Proof</span>.</span><br><span class=line>  <span class=built_in>intros</span> n.</span><br><span class=line>  <span class=built_in>simpl</span>. <span class=comment>(* n + 1은 reduction이 안 됨... *)</span></span><br><span class=line>  <span class=built_in>destruct</span> n.</span><br><span class=line>  - <span class=built_in>simpl</span>. <span class=built_in>reflexivity</span>. <span class=comment>(* 0 + 1은 reduction이 됨! *)</span></span><br><span class=line>  - <span class=built_in>simpl</span>. <span class=built_in>reflexivity</span>. <span class=comment>(* S n + 1은 reduction이 됨! *)</span></span><br><span class=line><span class=keyword>Qed</span>.</span><br></pre></table></figure><p>destruct는 Introduction에서 정의했던 constructor들로 나눠버림<p>이게 뭔 소리냐? 위의 경우에는 n은 nat임<br> 이때 그냥 nat을 정의했던대로 O인 경우, S n인 경우로 풀어서 쓸 수 있음!<p>원래 <code>(n + 1 =? 0) = false</code>인 goal을 두 개의 subgoal <code>(0 + 1 =? 0) = false</code>이랑 <code>(S n + 1 =? 0) = false</code>으로 풀어줌.<br> 만약 두 subgoal 모두 증명된다면 모든 constructor에서 증명했으니 모든 nat에 대해서 증명한게 되는거임!<p>사실 보통은 <code>destruct n as [| n'] eqn:E.</code>로 씀<br> <code>n'</code>은 n 돌려쓰면 헷갈리니까 subgoal에서는 <code>S n'</code>처럼 다른 변수로 쓰라고 하는거고,<br> <code>eqn:E</code>는 destruct한 가정을 E로 정의함 (첫 번째 subgoal에선 <code>E: n = 0</code>, 두 번째 subgoal에선 <code>E: n = S n'</code>)<p>induction도 비슷하게 <code>induction n as [| n' IHn']</code>처럼 정의할 수 있음!<h1>Rocq의 한계?</h1><p>Rocq는 constructive logic이기 때문에 명제를 증명할 때는 항상 실제로 증명 방법을 제시해야 함.<br> 하지만 constructive하게 증명을 만들어낼 수 없는 명제도 있음...<figure class="highlight coq"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>Theorem</span> baejungrule: <span class=keyword>forall</span> p: <span class=keyword>Prop</span>,</span><br><span class=line>  p \/ ~p.</span><br><span class=line><span class=keyword>Proof</span>. <span class=keyword>Admitted</span>.</span><br></pre></table></figure><p>이런 명제들은 Rocq에서 참이라는 증명을 할 수가 없음...<br> 왜냐? evidence(실제 증명)을 줄 수가 없음 <s>만약 evidence를 만들 수 있으면 p에 밀레니엄 문제 넣고 참인 evidence가 있는지 거짓인 evidence가 있는지 보고 10억 타면 됨</s><br> Rocq는 반드시 프로그램을 짜야 증명이 되기 때문에, 저걸 증명하려면 p의 프로그램을 짜거나 ~p의 프로그램을 짜야함. 하지만 이걸 임의의 Prop에 대해서 증명할 수가 없음...<p>이런 경우 Adimitted.를 써서 강제로 증명하거나 아예 <code>Axiom baejungrule: forall p: Prop, p \/ ~p.</code>처럼 애초에 이 명제는 참이라고 정의할 수 있음.<br> 하지만 이렇게 하면 Rocq를 사용하는 이유인 엄밀성이 깨지니까 웬만하면 쓰지 말자...<p>c.f. 괴델의 불완전성 정리: 수학체계는 스스로 수학체계가 무모순이라는 증명을 할 수가 없음</div><footer class=post-footer><div class=post-nav><div class=post-nav-item><a href=/posts/100/ rel=prev title=Introduction> <i class="fa fa-angle-left"></i> Introduction </a></div><div class=post-nav-item><a title="수의 체계" href=/posts/101/ rel=next> 수의 체계 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© 2023 – <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>CookieHCl</span></div><div class=powered-by>Powered by <a href=https://hexo.io/ rel=noopener target=_blank>Hexo</a> & <a href=https://theme-next.js.org/muse/ rel=noopener target=_blank>NexT.Muse</a></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label="Back to top" class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script class=next-config data-name=utterances type=application/json>{"enable":true,"repo":"CookieHCl/cookiehcl.github.io","issue_term":"pathname","theme":"github-light"}</script><script defer src=/js/third-party/comments/utterances.js></script>